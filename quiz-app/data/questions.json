{
  "questions": [
    {
      "id": 1,
      "category": "インフラストラクチャ",
      "question": "RAID5の特徴として正しいものはどれか？",
      "choices": [
        "ミラーリングにより冗長性を確保する",
        "パリティを分散配置し、1台のディスク障害に耐えられる",
        "ストライピングのみで冗長性がない",
        "最低2台のディスクで構成できる"
      ],
      "answer": 1,
      "explanation": "RAID5はパリティ（誤り訂正符号）を各ディスクに分散配置し、1台のディスク障害時でもデータを復元できます。最低3台のディスクが必要です。\n\n【他の選択肢】\n・ミラーリング → RAID1の特徴\n・ストライピングのみ（冗長性なし） → RAID0の特徴\n・最低2台で構成 → RAID0/1は2台から、RAID5は3台以上必要\n\n【覚え方】\nRAID0=速度重視（冗長性なし）、RAID1=ミラーリング、RAID5=パリティ分散、RAID6=2台故障対応",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 2,
      "category": "インフラストラクチャ",
      "question": "TCP/IPモデルにおいて、HTTPが動作する層はどれか？",
      "choices": [
        "ネットワークインターフェース層",
        "インターネット層",
        "トランスポート層",
        "アプリケーション層"
      ],
      "answer": 3,
      "explanation": "HTTPはアプリケーション層で動作するプロトコルです。Webブラウザとサーバー間の通信に使用されます。\n\n【TCP/IP 4層モデル】\n・アプリケーション層：HTTP, FTP, SMTP, DNS等\n・トランスポート層：TCP, UDP\n・インターネット層：IP, ICMP\n・ネットワークインターフェース層：Ethernet等\n\n【ポイント】\nOSI7層モデルでは第7層（アプリケーション層）に相当します。",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 3,
      "category": "インフラストラクチャ",
      "question": "OSI参照モデルの第3層（ネットワーク層）で動作する機器はどれか？",
      "choices": [
        "リピータ",
        "スイッチ",
        "ルータ",
        "ブリッジ"
      ],
      "answer": 2,
      "explanation": "ルータはOSI参照モデルの第3層（ネットワーク層）で動作し、IPアドレスを基にルーティングを行います。\n\n【他の選択肢】\n・リピータ → 第1層（物理層）：電気信号を増幅\n・スイッチ → 第2層（データリンク層）：MACアドレスで転送\n・ブリッジ → 第2層（データリンク層）：ネットワークを分割\n\n【覚え方】\nL1=リピータ/ハブ、L2=スイッチ/ブリッジ、L3=ルータ",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 4,
      "category": "インフラストラクチャ",
      "question": "NASの説明として正しいものはどれか？",
      "choices": [
        "サーバーに直接接続するストレージ",
        "ファイル単位でネットワーク共有するストレージ",
        "ブロック単位で高速アクセスするストレージネットワーク",
        "テープを使用したバックアップ装置"
      ],
      "answer": 1,
      "explanation": "NAS（Network Attached Storage）はネットワーク経由でファイル単位のアクセスを提供するストレージです。\n\n【ストレージの種類】\n・DAS（Direct Attached Storage）：サーバーに直接接続\n・NAS：ネットワーク経由でファイル単位でアクセス（NFS/SMB）\n・SAN（Storage Area Network）：専用ネットワークでブロック単位の高速アクセス\n\n【実務ポイント】\nNASは導入が容易でファイル共有に最適。SANは大規模DBなど高性能が求められる環境で使用されます。",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 5,
      "category": "インフラストラクチャ",
      "question": "SSHのデフォルトポート番号はどれか？",
      "choices": [
        "21",
        "22",
        "23",
        "25"
      ],
      "answer": 1,
      "explanation": "SSHはポート22を使用します。\n\n【主要ポート番号一覧】\n・20/21：FTP（データ/制御）\n・22：SSH（暗号化リモート接続）\n・23：Telnet（非暗号化、現在は非推奨）\n・25：SMTP（メール送信）\n・53：DNS\n・80：HTTP\n・443：HTTPS\n\n【実務ポイント】\nTelnet(23)は通信が暗号化されないため、現在はSSH(22)を使用するのが標準です。",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 6,
      "category": "インフラストラクチャ",
      "question": "RAID1の特徴として正しいものはどれか？",
      "choices": [
        "データを複数のディスクに分散して書き込む",
        "パリティ情報を使用してデータを保護する",
        "同じデータを複数のディスクに複製する",
        "冗長性がなく高速性を重視する"
      ],
      "answer": 2,
      "explanation": "RAID1はミラーリングと呼ばれ、同じデータを2台以上のディスクに複製します。1台が故障してもデータは保護されます。\n\n【他の選択肢】\n・データを分散して書き込む → RAID0（ストライピング）の特徴\n・パリティ情報を使用 → RAID5/6の特徴\n・冗長性がなく高速性重視 → RAID0の特徴\n\n【実務ポイント】\nRAID1は読み込み性能が向上しますが、容量効率は50%です。重要なシステムディスクやOSドライブに使用されることが多いです。",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 7,
      "category": "インフラストラクチャ",
      "question": "プライベートIPアドレスとして正しいものはどれか？",
      "choices": [
        "172.32.0.1",
        "192.168.1.1",
        "11.0.0.1",
        "191.168.1.1"
      ],
      "answer": 1,
      "explanation": "プライベートIPアドレスは以下の範囲で、インターネット上でルーティングされません。\n\n【プライベートIPアドレスの範囲】\n・クラスA：10.0.0.0 ～ 10.255.255.255（10.0.0.0/8）\n・クラスB：172.16.0.0 ～ 172.31.255.255（172.16.0.0/12）\n・クラスC：192.168.0.0 ～ 192.168.255.255（192.168.0.0/16）\n\n【他の選択肢が不正解の理由】\n・172.32.0.1 → 172.16～172.31の範囲外\n・11.0.0.1 → クラスAの10.x.x.xの範囲外\n・191.168.1.1 → 192.168ではない",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 8,
      "category": "インフラストラクチャ",
      "question": "MTBFとMTTRから稼働率を計算する式として正しいものはどれか？",
      "choices": [
        "MTTR / MTBF",
        "MTBF / MTTR",
        "MTBF / (MTBF + MTTR)",
        "(MTBF + MTTR) / MTBF"
      ],
      "answer": 2,
      "explanation": "稼働率 = MTBF / (MTBF + MTTR) です。\n\n【用語の意味】\n・MTBF（Mean Time Between Failures）：平均故障間隔（動いている時間）\n・MTTR（Mean Time To Repair）：平均修復時間（止まっている時間）\n\n【計算例】\nMTBF=990時間、MTTR=10時間の場合\n稼働率 = 990 / (990 + 10) = 0.99 = 99%\n\n【覚え方】\n稼働率 = 動いている時間 / 全体時間\n「MTBF÷（MTBF＋MTTR）」と覚えましょう。",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 9,
      "category": "インフラストラクチャ",
      "question": "DNSが使用するポート番号はどれか？",
      "choices": [
        "25",
        "53",
        "80",
        "443"
      ],
      "answer": 1,
      "explanation": "DNSはポート53を使用します（UDP/TCP両方）。\n\n【他の選択肢】\n・25：SMTP（メール送信）\n・80：HTTP（Webサイト）\n・443：HTTPS（暗号化Web通信）\n\n【DNS関連の補足】\n・通常のクエリはUDP 53を使用（高速）\n・ゾーン転送やサイズが大きい応答はTCP 53を使用\n・DNS over HTTPS（DoH）は443を使用\n\n【試験対策】\nポート番号は頻出です。53=DNS、80=HTTP、443=HTTPS、22=SSHは必ず覚えましょう。",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 10,
      "category": "インフラストラクチャ",
      "question": "サブネットマスク /24 のホスト数として正しいものはどれか？",
      "choices": [
        "254",
        "255",
        "256",
        "512"
      ],
      "answer": 0,
      "explanation": "/24はホスト部が8ビットで256アドレスですが、ネットワークアドレスとブロードキャストを除くと254ホストが利用可能です。\n\n【計算方法】\nホスト数 = 2^(ホスト部ビット数) - 2\n/24の場合：2^8 - 2 = 256 - 2 = 254\n\n【-2する理由】\n・ネットワークアドレス（全ビット0）：ネットワーク自体を表す\n・ブロードキャストアドレス（全ビット1）：一斉送信用\n\n【よく出るサブネット】\n・/24 → 254ホスト\n・/25 → 126ホスト\n・/26 → 62ホスト\n・/27 → 30ホスト",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 11,
      "category": "OS・ミドルウェア",
      "question": "Linuxでファイルの権限を変更するコマンドはどれか？",
      "choices": [
        "chown",
        "chmod",
        "chgrp",
        "ls"
      ],
      "answer": 1,
      "explanation": "chmodはファイルやディレクトリのアクセス権限（パーミッション）を変更するコマンドです。\n\n【Linuxの権限変更コマンド】\n・chmod：権限（パーミッション）を変更\n・chown：所有者を変更\n・chgrp：グループを変更\n\n【chmodの使い方】\n・数値指定：chmod 755 file（rwxr-xr-x）\n・記号指定：chmod u+x file（所有者に実行権限追加）\n\n【覚え方】\nchmod=change mode、chown=change owner、chgrp=change group",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 12,
      "category": "OS・ミドルウェア",
      "question": "Active Directoryの主な機能として適切でないものはどれか？",
      "choices": [
        "ユーザー認証",
        "グループポリシーの適用",
        "Webサーバーの負荷分散",
        "ディレクトリサービス"
      ],
      "answer": 2,
      "explanation": "Active Directoryは認証、グループポリシー、ディレクトリサービスを提供しますが、Webサーバーの負荷分散は別のソリューションで行います。\n\n【Active Directoryの主な機能】\n・ユーザー認証：シングルサインオン（SSO）\n・グループポリシー：一括設定管理\n・ディレクトリサービス：ユーザー/PC情報の一元管理\n・LDAP：ディレクトリ情報の検索プロトコル\n\n【関連用語】\n・ドメインコントローラー：ADを管理するサーバー\n・OU（組織単位）：管理単位のグループ化",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 13,
      "category": "OS・ミドルウェア",
      "question": "Linuxで設定ファイルが格納されるディレクトリはどれか？",
      "choices": [
        "/bin",
        "/etc",
        "/var",
        "/home"
      ],
      "answer": 1,
      "explanation": "/etcディレクトリにはシステムの設定ファイルが格納されます。\n\n【主なLinuxディレクトリ】\n・/etc：設定ファイル（passwd, hosts等）\n・/bin：基本コマンド（ls, cp等）\n・/sbin：管理者用コマンド\n・/var：可変データ（ログ、キャッシュ）\n・/home：ユーザーホームディレクトリ\n・/tmp：一時ファイル\n・/usr：ユーザー用プログラム\n・/opt：追加アプリケーション\n\n【覚え方】\netc = et cetera（その他）= 設定いろいろ",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 14,
      "category": "OS・ミドルウェア",
      "question": "Linuxのパーミッション「755」の意味として正しいものはどれか？",
      "choices": [
        "所有者：読取のみ、グループ：読取書込、その他：全権限",
        "所有者：全権限、グループ：読取実行、その他：読取実行",
        "所有者：読取書込、グループ：読取、その他：読取",
        "所有者：実行のみ、グループ：全権限、その他：全権限"
      ],
      "answer": 1,
      "explanation": "755は所有者がrwx(7)、グループがr-x(5)、その他がr-x(5)を意味します。\n\n【パーミッションの数値】\n・r（読取）= 4\n・w（書込）= 2\n・x（実行）= 1\n\n【計算方法】\n7 = 4+2+1 = rwx（全権限）\n5 = 4+0+1 = r-x（読取と実行）\n6 = 4+2+0 = rw-（読取と書込）\n\n【よく使うパーミッション】\n・755：実行ファイル/ディレクトリ\n・644：一般ファイル\n・600：秘密ファイル（所有者のみ）",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 15,
      "category": "OS・ミドルウェア",
      "question": "Webサーバーソフトウェアとして適切でないものはどれか？",
      "choices": [
        "Apache",
        "Nginx",
        "Tomcat",
        "MySQL"
      ],
      "answer": 3,
      "explanation": "MySQLはデータベース管理システム（RDBMS）であり、Webサーバーではありません。\n\n【Webサーバーソフトウェア】\n・Apache：最も普及、モジュールで拡張\n・Nginx：軽量、高性能、リバースプロキシ\n・IIS：Windows標準\n\n【アプリケーションサーバー】\n・Tomcat：Java Servlet/JSP実行環境\n・JBoss/WildFly：Java EE対応\n\n【データベース】\n・MySQL、PostgreSQL、Oracle、SQL Server\n\n【補足】\nTomcatは厳密にはAPサーバーですが、HTTP処理も可能です。",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 16,
      "category": "OS・ミドルウェア",
      "question": "Linuxでプロセスをリアルタイムで監視するコマンドはどれか？",
      "choices": [
        "ps",
        "top",
        "kill",
        "ls"
      ],
      "answer": 1,
      "explanation": "topコマンドはCPU使用率やメモリ使用量などをリアルタイムで表示します。\n\n【プロセス関連コマンド】\n・top：リアルタイム監視（対話的に更新）\n・htop：topの高機能版（色付き、操作しやすい）\n・ps：プロセス一覧のスナップショット\n・kill：プロセスを終了\n・pgrep：プロセスをパターン検索\n\n【topで確認できる情報】\n・CPU使用率\n・メモリ使用量\n・実行中プロセス一覧\n・ロードアベレージ",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 17,
      "category": "OS・ミドルウェア",
      "question": "Windowsのファイルシステムで、暗号化や圧縮に対応しているものはどれか？",
      "choices": [
        "FAT32",
        "exFAT",
        "NTFS",
        "FAT16"
      ],
      "answer": 2,
      "explanation": "NTFSはファイル暗号化（EFS）、圧縮、アクセス権制御などの機能を持つWindowsの標準ファイルシステムです。\n\n【Windowsファイルシステム比較】\n| FS | 最大ファイル | 暗号化 | 圧縮 | 用途 |\n|-----|------------|--------|------|------|\n| NTFS | 16EB | ○ | ○ | 内蔵ドライブ |\n| exFAT | 16EB | × | × | USBメモリ |\n| FAT32 | 4GB | × | × | 古い機器 |\n\n【NTFSの主な機能】\n・EFS（暗号化ファイルシステム）\n・ファイル圧縮\n・ACL（アクセス制御リスト）\n・ジャーナリング（障害復旧）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 18,
      "category": "OS・ミドルウェア",
      "question": "Linuxの定期実行スケジューラはどれか？",
      "choices": [
        "systemd",
        "cron",
        "init",
        "daemon"
      ],
      "answer": 1,
      "explanation": "cronは指定した日時にコマンドやスクリプトを自動実行するスケジューラです。\n\n【crontabの書式】\n分 時 日 月 曜日 コマンド\n例：0 3 * * * /backup.sh\n　→毎日3:00にbackup.shを実行\n\n【他の選択肢】\n・systemd：サービス管理（init後継）\n・init：起動時のプロセス管理（旧式）\n・daemon：バックグラウンドプロセスの総称\n\n【関連】\n・at：1回だけの予約実行\n・anacron：PC起動時に未実行ジョブを実行",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 19,
      "category": "OS・ミドルウェア",
      "question": "カーネルの種類で、全機能を1つのカーネルに統合したものはどれか？",
      "choices": [
        "マイクロカーネル",
        "モノリシックカーネル",
        "ハイブリッドカーネル",
        "エクソカーネル"
      ],
      "answer": 1,
      "explanation": "モノリシックカーネルは全ての機能を1つのカーネル空間で実行します。Linuxがその代表例です。\n\n【カーネルの種類】\n・モノリシック：全機能統合、高速（Linux、Unix）\n・マイクロ：最小限の機能、安定性重視（Minix、QNX）\n・ハイブリッド：両者の中間（Windows NT、macOS）\n\n【他の選択肢】\n・マイクロカーネル：機能を最小限にしユーザー空間で実行\n・ハイブリッド：モノリシックとマイクロの中間\n・エクソカーネル：リソース管理を最小化した研究用",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 20,
      "category": "OS・ミドルウェア",
      "question": "Debian/Ubuntu系Linuxでパッケージを管理するコマンドはどれか？",
      "choices": [
        "yum",
        "apt",
        "pacman",
        "rpm"
      ],
      "answer": 1,
      "explanation": "aptはDebian/Ubuntu系で使用されるパッケージ管理コマンドです。\n\n【Linuxディストリビューションとパッケージ管理】\n| ディストリ | コマンド | パッケージ形式 |\n|------------|----------|----------------|\n| Debian/Ubuntu | apt | .deb |\n| RHEL/CentOS | yum/dnf | .rpm |\n| Arch | pacman | .pkg.tar |\n| openSUSE | zypper | .rpm |\n\n【aptの主なコマンド】\n・apt update：パッケージ情報更新\n・apt install：インストール\n・apt remove：削除\n・apt upgrade：全パッケージ更新",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 21,
      "category": "データベース",
      "question": "SQLにおいて、テーブルから特定の列だけを取り出す操作を何というか？",
      "choices": [
        "選択（Selection）",
        "射影（Projection）",
        "結合（Join）",
        "和（Union）"
      ],
      "answer": 1,
      "explanation": "射影（Projection）は特定の列を取り出す操作です。選択（Selection）は特定の行を取り出す操作です。\n\n【関係演算の種類】\n・射影（Projection）：列を抽出（SELECT col1, col2）\n・選択（Selection）：行を抽出（WHERE条件）\n・結合（Join）：複数テーブルを結合\n・和（Union）：結果を統合\n\n【覚え方】\n射影 = 縦に切る（列）\n選択 = 横に切る（行）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 22,
      "category": "データベース",
      "question": "トランザクションのACID特性に含まれないものはどれか？",
      "choices": [
        "原子性（Atomicity）",
        "一貫性（Consistency）",
        "可用性（Availability）",
        "永続性（Durability）"
      ],
      "answer": 2,
      "explanation": "ACID特性は原子性(A)、一貫性(C)、独立性(I:Isolation)、永続性(D)の4つです。可用性はACIDには含まれません。\n\n【ACID特性の意味】\n・A（Atomicity）原子性：全て成功か全て失敗\n・C（Consistency）一貫性：整合性のある状態を維持\n・I（Isolation）独立性：他のトランザクションと干渉しない\n・D（Durability）永続性：コミット後のデータは永続的に保存\n\n【補足】\n可用性（Availability）はCAP定理の要素であり、ACIDとは別の概念です。",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 23,
      "category": "データベース",
      "question": "第3正規形の条件として正しいものはどれか？",
      "choices": [
        "繰り返し項目がないこと",
        "部分関数従属がないこと",
        "推移関数従属がないこと",
        "結合従属性がないこと"
      ],
      "answer": 2,
      "explanation": "第3正規形は第2正規形の条件に加え、推移関数従属がないことが条件です。\n\n【正規形の段階】\n・第1正規形：繰り返し項目がない（1セルに1値）\n・第2正規形：部分関数従属がない（複合キーの一部への依存なし）\n・第3正規形：推移関数従属がない（非キー→非キーの依存なし）\n\n【例：推移関数従属】\n社員番号→部署コード→部署名\n↑ 社員番号から部署名への間接的な依存\n→ 部署テーブルを分離して解消",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 24,
      "category": "データベース",
      "question": "SQLでテーブルを作成するコマンドはどれか？",
      "choices": [
        "INSERT",
        "CREATE",
        "ALTER",
        "UPDATE"
      ],
      "answer": 1,
      "explanation": "CREATE TABLE文でテーブルを作成します。\n\n【SQLコマンドの分類】\n・DDL（データ定義言語）\n　CREATE：作成、ALTER：変更、DROP：削除、TRUNCATE：全削除\n・DML（データ操作言語）\n　SELECT：検索、INSERT：挿入、UPDATE：更新、DELETE：削除\n・DCL（データ制御言語）\n　GRANT：権限付与、REVOKE：権限取消\n\n【他の選択肢】\n・INSERT：データ挿入（DML）\n・ALTER：構造変更（DDL）\n・UPDATE：データ更新（DML）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 25,
      "category": "データベース",
      "question": "INNER JOINの説明として正しいものはどれか？",
      "choices": [
        "左テーブルの全レコードと一致する右テーブルのレコードを返す",
        "右テーブルの全レコードと一致する左テーブルのレコードを返す",
        "両方のテーブルで一致するレコードのみを返す",
        "両方のテーブルの全レコードを返す"
      ],
      "answer": 2,
      "explanation": "INNER JOINは両方のテーブルで結合条件に一致するレコードのみを返します。\n\n【JOINの種類】\n・INNER JOIN：両方に一致するレコードのみ\n・LEFT JOIN：左テーブル全て＋一致する右テーブル\n・RIGHT JOIN：右テーブル全て＋一致する左テーブル\n・FULL OUTER JOIN：両方の全レコード（一致しなくてもNULLで補完）\n・CROSS JOIN：全組み合わせ（直積）\n\n【使い分け】\n・必ずある関連→INNER JOIN\n・なくても表示→LEFT/RIGHT JOIN",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 26,
      "category": "データベース",
      "question": "NoSQLデータベースの種類として適切でないものはどれか？",
      "choices": [
        "キー・バリュー型",
        "ドキュメント型",
        "リレーショナル型",
        "グラフ型"
      ],
      "answer": 2,
      "explanation": "リレーショナル型はRDBMSであり、NoSQLではありません。\n\n【NoSQLの種類と代表例】\n・キー・バリュー型：Redis、Memcached（高速キャッシュ）\n・ドキュメント型：MongoDB、CouchDB（JSON形式）\n・カラム指向型：Cassandra、HBase（大規模分散）\n・グラフ型：Neo4j（関係性のあるデータ）\n\n【RDBMSとNoSQLの使い分け】\n・RDBMS：トランザクション重視、複雑なクエリ\n・NoSQL：スケーラビリティ重視、柔軟なスキーマ",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 27,
      "category": "データベース",
      "question": "インデックスの効果として正しいものはどれか？",
      "choices": [
        "INSERT処理が高速になる",
        "DELETE処理が高速になる",
        "SELECT処理が高速になる",
        "UPDATE処理が高速になる"
      ],
      "answer": 2,
      "explanation": "インデックスは検索（SELECT）を高速化しますが、INSERT/UPDATE/DELETEはインデックス更新のオーバーヘッドで遅くなることがあります。\n\n【インデックスの仕組み】\n・B木やハッシュでデータ位置を高速検索\n・主キーには自動でインデックス作成\n・WHERE句やJOINの条件列に作成すると効果的\n\n【インデックスのデメリット】\n・ディスク容量を消費\n・データ更新時にインデックスも更新が必要\n・過剰なインデックスは逆効果\n\n【作成例】\nCREATE INDEX idx_name ON users(name);",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 28,
      "category": "データベース",
      "question": "CAP定理で、分散システムが同時に満たせるのは何個までか？",
      "choices": [
        "1個",
        "2個",
        "3個",
        "4個"
      ],
      "answer": 1,
      "explanation": "CAP定理では、一貫性(C)、可用性(A)、分断耐性(P)のうち、同時に満たせるのは2つまでです。\n\n【CAP定理の要素】\n・C（Consistency）一貫性：全ノードで同じデータ\n・A（Availability）可用性：常に応答を返す\n・P（Partition tolerance）分断耐性：ネットワーク障害に耐える\n\n【分散DBの選択】\n・CP型：一貫性重視（HBase、MongoDB）\n・AP型：可用性重視（Cassandra、DynamoDB）\n・CA型：理論上は存在するが分散環境では非現実的\n\n【実務ポイント】\n分散システムではPは必須のため、実質CかAの選択になります。",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 29,
      "category": "データベース",
      "question": "SQLでGROUP BYと組み合わせて使用し、グループの条件を指定するものはどれか？",
      "choices": [
        "WHERE",
        "ORDER BY",
        "HAVING",
        "LIMIT"
      ],
      "answer": 2,
      "explanation": "HAVINGはGROUP BY後のグループに対する条件を指定します。WHEREはグループ化前の行に対する条件です。\n\n【WHERE vs HAVING】\n・WHERE：グループ化前の行に対する条件\n・HAVING：グループ化後の集計結果に対する条件\n\n【SQL実行順序】\n1. FROM → 2. WHERE → 3. GROUP BY → 4. HAVING → 5. SELECT → 6. ORDER BY\n\n【使用例】\nSELECT dept, COUNT(*) as cnt\nFROM employees\nWHERE age >= 20\nGROUP BY dept\nHAVING COUNT(*) >= 5\n（20歳以上で5人以上の部署）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 30,
      "category": "データベース",
      "question": "デッドロックの説明として正しいものはどれか？",
      "choices": [
        "トランザクションが長時間実行される状態",
        "複数のトランザクションが互いに相手のロック解放を待つ状態",
        "データベースの容量が不足した状態",
        "インデックスが破損した状態"
      ],
      "answer": 1,
      "explanation": "デッドロックは複数のトランザクションが互いにロックを保持しながら、相手のロック解放を待ち続ける状態です。\n\n【デッドロックの例】\nトランザクションA：テーブル1をロック → テーブル2を待つ\nトランザクションB：テーブル2をロック → テーブル1を待つ\n→ 永久に待ち続ける\n\n【対策】\n・ロック順序を統一する\n・タイムアウトを設定する\n・DBMSの自動検出・解消機能を利用\n\n【他の選択肢】\n・長時間実行 → パフォーマンス問題\n・容量不足 → ストレージ問題\n・インデックス破損 → 整合性問題",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 31,
      "category": "アプリケーション",
      "question": "アジャイル開発手法の特徴として正しいものはどれか？",
      "choices": [
        "最初に全ての要件を確定させる",
        "短いイテレーションで開発を繰り返す",
        "ドキュメントを最重視する",
        "変更要求を受け付けない"
      ],
      "answer": 1,
      "explanation": "アジャイル開発は短いイテレーション（スプリント）で開発を繰り返し、変化に柔軟に対応することを重視します。\n\n【アジャイル開発の特徴】\n・短いイテレーション（1-4週間）\n・顧客との密なコミュニケーション\n・変更への柔軟な対応\n・動くソフトウェアを重視\n\n【代表的な手法】\n・スクラム、XP（エクストリームプログラミング）、カンバン\n\n【他の選択肢（ウォーターフォールの特徴）】\n・最初に要件確定、ドキュメント重視、変更困難",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 32,
      "category": "アプリケーション",
      "question": "REST APIの特徴として適切でないものはどれか？",
      "choices": [
        "ステートレスな通信",
        "HTTPメソッドを活用",
        "SOAPより軽量",
        "必ずXML形式でデータを送受信"
      ],
      "answer": 3,
      "explanation": "REST APIは一般的にJSONを使用することが多く、XML形式に限定されません。\n\n【RESTの原則】\n・ステートレス：サーバーはセッション状態を保持しない\n・統一インターフェース：HTTPメソッドで操作を表現\n・リソース指向：URLでリソースを識別\n・表現の分離：JSON/XMLなど複数形式対応\n\n【REST vs SOAP】\n・REST：軽量、JSON、柔軟\n・SOAP：厳格、XML必須、WS-Security対応",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 33,
      "category": "アプリケーション",
      "question": "オブジェクト指向の三大要素に含まれないものはどれか？",
      "choices": [
        "カプセル化",
        "継承",
        "ポリモーフィズム",
        "正規化"
      ],
      "answer": 3,
      "explanation": "オブジェクト指向の三大要素はカプセル化、継承、ポリモーフィズムです。正規化はデータベース設計の概念です。\n\n【三大要素の説明】\n・カプセル化：データと処理をまとめ、外部から隠蔽\n・継承：既存クラスの機能を引き継ぎ拡張\n・ポリモーフィズム：同じインターフェースで異なる動作\n\n【その他の重要概念】\n・抽象化：共通の特徴を抽出\n・クラス/インスタンス\n・インターフェース",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 34,
      "category": "アプリケーション",
      "question": "HTTPメソッドのPUTの用途として正しいものはどれか？",
      "choices": [
        "リソースの取得",
        "リソースの作成",
        "リソースの更新（全体）",
        "リソースの削除"
      ],
      "answer": 2,
      "explanation": "PUTはリソースの更新（全体置換）に使用します。\n\n【主要HTTPメソッド】\n| メソッド | 用途 | 冪等性 |\n|----------|------|--------|\n| GET | 取得 | ○ |\n| POST | 作成 | × |\n| PUT | 更新（全体） | ○ |\n| PATCH | 更新（部分） | × |\n| DELETE | 削除 | ○ |\n\n【PUT vs PATCH】\n・PUT：リソース全体を置換\n・PATCH：リソースの一部を更新",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 35,
      "category": "アプリケーション",
      "question": "計算量O(n log n)のソートアルゴリズムはどれか？",
      "choices": [
        "バブルソート",
        "挿入ソート",
        "マージソート",
        "選択ソート"
      ],
      "answer": 2,
      "explanation": "マージソートの平均・最悪計算量はO(n log n)です。\n\n【ソートアルゴリズムの計算量】\n| アルゴリズム | 平均 | 最悪 |\n|--------------|------|------|\n| バブルソート | O(n²) | O(n²) |\n| 挿入ソート | O(n²) | O(n²) |\n| 選択ソート | O(n²) | O(n²) |\n| マージソート | O(n log n) | O(n log n) |\n| クイックソート | O(n log n) | O(n²) |\n| ヒープソート | O(n log n) | O(n log n) |\n\n【実務ポイント】\n多くの言語の標準ソートはクイックソートやマージソートを採用",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 36,
      "category": "アプリケーション",
      "question": "Gitでリモートリポジトリの変更を取得してマージするコマンドはどれか？",
      "choices": [
        "git push",
        "git pull",
        "git fetch",
        "git clone"
      ],
      "answer": 1,
      "explanation": "git pullはfetch+mergeを行い、リモートの変更を取得してマージします。\n\n【主要Gitコマンド】\n・git clone：リポジトリをコピー\n・git fetch：リモートの変更を取得（マージしない）\n・git pull：fetch + merge（取得してマージ）\n・git push：ローカルの変更をリモートにアップロード\n・git merge：ブランチを統合\n・git rebase：コミット履歴を整理\n\n【pull vs fetch】\n・pull = fetch + merge（一気に反映）\n・fetch = 取得のみ（確認してからmerge可能）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 37,
      "category": "アプリケーション",
      "question": "スクラム開発におけるプロダクトオーナーの役割として正しいものはどれか？",
      "choices": [
        "チームの障害を取り除く",
        "プロダクトバックログを管理する",
        "デイリースクラムを主催する",
        "コードレビューを行う"
      ],
      "answer": 1,
      "explanation": "プロダクトオーナーはプロダクトバックログの管理と優先順位付けを担当します。\n\n【スクラムの3つの役割】\n・プロダクトオーナー：プロダクトバックログ管理、優先順位決定、ステークホルダーとの調整\n・スクラムマスター：プロセスの促進、障害の除去、チームの支援\n・開発チーム：自己組織化されたチームで開発を実施\n\n【スクラムイベント】\n・スプリント計画、デイリースクラム、スプリントレビュー、レトロスペクティブ",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 38,
      "category": "アプリケーション",
      "question": "テスト駆動開発（TDD）の進め方として正しいものはどれか？",
      "choices": [
        "実装→テスト→リファクタリング",
        "テスト→実装→リファクタリング",
        "リファクタリング→テスト→実装",
        "設計→実装→テスト"
      ],
      "answer": 1,
      "explanation": "TDDは「レッド（テスト失敗）→グリーン（テスト成功）→リファクタリング」のサイクルで進めます。\n\n【TDDのサイクル】\n1. Red：失敗するテストを書く\n2. Green：テストを通す最小限のコードを書く\n3. Refactor：コードを改善（テストは通したまま）\n\n【TDDのメリット】\n・バグの早期発見\n・設計の改善（テストしやすい設計になる）\n・リファクタリングの安全性確保\n・ドキュメントとしてのテスト",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 39,
      "category": "アプリケーション",
      "question": "MVCアーキテクチャのControllerの役割として正しいものはどれか？",
      "choices": [
        "データの管理と操作",
        "画面の表示",
        "入力を受け取りModelとViewを制御",
        "データベースへのアクセス"
      ],
      "answer": 2,
      "explanation": "Controllerはユーザーからのリクエストを受け取り、ModelとViewを適切に制御する役割を持ちます。\n\n【MVCの役割】\n・Model：データと業務ロジック（DBアクセス含む）\n・View：画面表示（UI/テンプレート）\n・Controller：入力処理、ModelとViewの仲介\n\n【処理の流れ】\n1. ユーザーがリクエスト\n2. Controller がリクエストを受信\n3. Controller が Model にデータ操作を依頼\n4. Controller が View にデータを渡して表示",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 40,
      "category": "アプリケーション",
      "question": "CI/CDのCIが意味するものはどれか？",
      "choices": [
        "Continuous Integration",
        "Continuous Improvement",
        "Code Inspection",
        "Customer Interface"
      ],
      "answer": 0,
      "explanation": "CIはContinuous Integration（継続的インテグレーション）の略で、コードの変更を頻繁に統合し自動テストを行う手法です。\n\n【CI/CDの意味】\n・CI（Continuous Integration）：継続的インテグレーション\n　コードを頻繁にマージし自動ビルド・テスト\n・CD（Continuous Delivery/Deployment）：継続的デリバリー/デプロイ\n　自動的に本番環境へリリース\n\n【代表的なCI/CDツール】\n・Jenkins、GitHub Actions、GitLab CI、CircleCI",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 41,
      "category": "クラウド",
      "question": "IaaS、PaaS、SaaSのうち、最もユーザーの管理範囲が広いものはどれか？",
      "choices": [
        "SaaS",
        "PaaS",
        "IaaS",
        "すべて同じ"
      ],
      "answer": 2,
      "explanation": "IaaS（Infrastructure as a Service）はインフラのみを提供するため、OS、ミドルウェア、アプリケーションはユーザーが管理します。管理範囲はIaaS > PaaS > SaaSの順です。\n\n【クラウドサービスモデルの管理範囲】\n| 項目 | IaaS | PaaS | SaaS |\n|------|------|------|------|\n| アプリ | ユーザー | ユーザー | 事業者 |\n| ミドルウェア | ユーザー | 事業者 | 事業者 |\n| OS | ユーザー | 事業者 | 事業者 |\n| 仮想化/HW | 事業者 | 事業者 | 事業者 |\n\n【代表的なサービス例】\n・IaaS：AWS EC2、Azure VM、GCE\n・PaaS：Heroku、AWS Elastic Beanstalk、Google App Engine\n・SaaS：Gmail、Salesforce、Office 365\n\n【覚え方】\nSaaS=ソフトウェアまで提供、PaaS=プラットフォームまで、IaaS=インフラのみ→上にいくほど事業者の管理範囲が広い",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 42,
      "category": "クラウド",
      "question": "コンテナ技術の特徴として正しいものはどれか？",
      "choices": [
        "ハイパーバイザー上で動作する",
        "各コンテナが独自のOSカーネルを持つ",
        "ホストOSのカーネルを共有する",
        "仮想マシンより起動が遅い"
      ],
      "answer": 2,
      "explanation": "コンテナはホストOSのカーネルを共有するため、仮想マシンより軽量で起動が高速です。Dockerが代表的なコンテナ技術です。\n\n【コンテナと仮想マシンの比較】\n| 項目 | コンテナ | 仮想マシン |\n|------|----------|------------|\n| カーネル | ホストOSと共有 | 各自で持つ |\n| 起動時間 | 秒単位 | 分単位 |\n| リソース | 軽量 | 重い |\n| 分離レベル | プロセス分離 | 完全分離 |\n\n【他の選択肢】\n・ハイパーバイザー上で動作 → 仮想マシンの特徴\n・独自のOSカーネルを持つ → 仮想マシンの特徴\n・起動が遅い → コンテナは高速起動が特徴\n\n【覚え方】\nコンテナ=「軽い箱」、VM=「まるごとパソコン」と覚える。DockerはコンテナをPackaging（梱包）する技術",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 43,
      "category": "クラウド",
      "question": "AWS EC2は何のサービスか？",
      "choices": [
        "オブジェクトストレージ",
        "仮想サーバー",
        "マネージドデータベース",
        "サーバーレス関数"
      ],
      "answer": 1,
      "explanation": "EC2（Elastic Compute Cloud）はAWSの仮想サーバーサービスです。S3がストレージ、RDSがDB、Lambdaがサーバーレスです。\n\n【AWSの主要サービス一覧】\n| サービス | 種類 | 用途 |\n|----------|------|------|\n| EC2 | コンピュート | 仮想サーバー |\n| S3 | ストレージ | オブジェクト保存 |\n| RDS | データベース | マネージドRDB |\n| Lambda | コンピュート | サーバーレス関数 |\n| DynamoDB | データベース | NoSQL |\n| VPC | ネットワーク | 仮想ネットワーク |\n\n【他の選択肢】\n・オブジェクトストレージ → S3（Simple Storage Service）\n・マネージドデータベース → RDS（Relational Database Service）\n・サーバーレス関数 → Lambda\n\n【覚え方】\nEC2の「C」はCompute（コンピュート）のC。E=Elastic（弾力的）でスケールできる",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 44,
      "category": "クラウド",
      "question": "Kubernetesの最小デプロイ単位は何か？",
      "choices": [
        "Container",
        "Pod",
        "Node",
        "Cluster"
      ],
      "answer": 1,
      "explanation": "Podは1つ以上のコンテナをまとめたKubernetesの最小デプロイ単位です。\n\n【Kubernetesの階層構造】\nCluster > Node > Pod > Container\n・Cluster：Kubernetesクラスター全体\n・Node：実際のサーバー（物理/仮想）\n・Pod：コンテナをまとめた最小単位\n・Container：アプリケーション実行環境\n\n【他の選択肢】\n・Container → Podの中に含まれる要素\n・Node → Podが動作するホストマシン\n・Cluster → Node群の集合体\n\n【覚え方】\nPod=「豆のさや」。さや（Pod）の中に豆（Container）が入っている。デプロイ時はさや単位で扱う",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 45,
      "category": "クラウド",
      "question": "サーバーレスアーキテクチャの特徴として正しいものはどれか？",
      "choices": [
        "常時サーバーが稼働している",
        "サーバーの管理が必要",
        "イベント駆動で実行される",
        "固定料金で課金される"
      ],
      "answer": 2,
      "explanation": "サーバーレスはイベント駆動で実行され、実行時間に応じた従量課金となります。サーバー管理は不要です。\n\n【サーバーレスの特徴】\n・イベント駆動：リクエスト時のみ起動\n・従量課金：実行時間×メモリで課金\n・自動スケール：負荷に応じて自動拡張\n・インフラ管理不要：OS/サーバー管理は事業者\n\n【他の選択肢】\n・常時サーバー稼働 → 従来のサーバー型\n・サーバー管理必要 → サーバーレスは管理不要\n・固定料金 → 従量課金が特徴\n\n【代表的なサービス】\n・AWS Lambda、Azure Functions、Cloud Functions（GCP）\n\n【覚え方】\nサーバー「レス」=サーバーの管理が「Less（少ない/不要）」。使った分だけ課金される「タクシーメーター型」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 46,
      "category": "クラウド",
      "question": "クラウドの責任共有モデルにおいて、IaaSでユーザーが責任を持つものはどれか？",
      "choices": [
        "物理的なデータセンターのセキュリティ",
        "ハイパーバイザーの管理",
        "OS・ミドルウェアの管理",
        "ネットワークインフラの管理"
      ],
      "answer": 2,
      "explanation": "IaaSではOS以上のレイヤー（OS、ミドルウェア、アプリケーション、データ）はユーザーの責任です。\n\n【責任共有モデル（IaaSの場合）】\n| 項目 | 責任者 |\n|------|--------|\n| データ | ユーザー |\n| アプリケーション | ユーザー |\n| ミドルウェア | ユーザー |\n| OS | ユーザー |\n| 仮想化 | クラウド事業者 |\n| ネットワークインフラ | クラウド事業者 |\n| 物理データセンター | クラウド事業者 |\n\n【他の選択肢】\n・物理DC/ハイパーバイザー/ネットワークインフラ → 事業者の責任\n\n【覚え方】\nIaaSは「下（Infrastructure）だけお任せ」。上層（OS〜アプリ）は自分で管理",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 47,
      "category": "クラウド",
      "question": "複数のクラウドプロバイダーを組み合わせて利用する形態を何というか？",
      "choices": [
        "プライベートクラウド",
        "パブリッククラウド",
        "ハイブリッドクラウド",
        "マルチクラウド"
      ],
      "answer": 3,
      "explanation": "マルチクラウドは複数のクラウドプロバイダー（AWS、Azure、GCP等）を組み合わせて利用する形態です。\n\n【クラウド形態の比較】\n| 形態 | 説明 |\n|------|------|\n| パブリッククラウド | 共有インフラを利用（AWS等） |\n| プライベートクラウド | 専用インフラ（オンプレ/専用クラウド） |\n| ハイブリッドクラウド | パブリック＋プライベートの組み合わせ |\n| マルチクラウド | 複数のパブリッククラウドを組み合わせ |\n\n【マルチクラウドのメリット】\n・ベンダーロックイン回避\n・各社の強みを活用\n・障害時のリスク分散\n\n【覚え方】\nマルチ=「複数」。ハイブリッド=「異種混合（パブリック＋プライベート）」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 48,
      "category": "クラウド",
      "question": "Infrastructure as Codeの代表的なツールはどれか？",
      "choices": [
        "Docker",
        "Kubernetes",
        "Terraform",
        "Jenkins"
      ],
      "answer": 2,
      "explanation": "TerraformはHashiCorp社のIaCツールで、インフラをコードで定義・管理できます。\n\n【IaC（Infrastructure as Code）のメリット】\n・バージョン管理が可能\n・環境の再現性が高い\n・手作業によるミスを防止\n・コードレビューが可能\n\n【他の選択肢】\n・Docker → コンテナ化ツール（アプリの実行環境をパッケージ化）\n・Kubernetes → コンテナオーケストレーション\n・Jenkins → CI/CDツール（ビルド・テスト自動化）\n\n【代表的なIaCツール】\n・Terraform（マルチクラウド対応）\n・AWS CloudFormation（AWS専用）\n・Ansible（構成管理）\n・Pulumi（プログラミング言語で記述）\n\n【覚え方】\nTerraform=Terra（地球）+form（形作る）→インフラを形作るツール",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 49,
      "category": "クラウド",
      "question": "12 Factor Appの原則に含まれないものはどれか？",
      "choices": [
        "設定を環境変数で管理する",
        "ステートレスなプロセス",
        "単一のプログラミング言語を使用する",
        "ログをイベントストリームとして扱う"
      ],
      "answer": 2,
      "explanation": "12 Factor Appにプログラミング言語の制限はありません。環境変数での設定、ステートレス、ログのストリーム化は含まれます。\n\n【12 Factor Appの主要原則】\n1. コードベース：1アプリ=1リポジトリ\n2. 依存関係：明示的に宣言\n3. 設定：環境変数で管理（※試験頻出）\n4. バックエンドサービス：リソースとして扱う\n5. ビルド・リリース・実行：厳密に分離\n6. プロセス：ステートレス（※試験頻出）\n7. ポートバインディング：サービスをポートで公開\n8. 並行性：プロセスモデルでスケール\n9. 廃棄容易性：高速起動・グレースフルシャットダウン\n10. 開発/本番一致：環境差異を最小化\n11. ログ：イベントストリームとして扱う（※試験頻出）\n12. 管理プロセス：1回限りのタスク\n\n【覚え方】\n12 Factor=クラウドネイティブアプリの「12箇条」。言語に依存しない設計指針",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 50,
      "category": "クラウド",
      "question": "CDN（Content Delivery Network）の主な目的はどれか？",
      "choices": [
        "データベースの高速化",
        "コンテンツの分散配信と高速化",
        "アプリケーションの開発",
        "セキュリティの強化"
      ],
      "answer": 1,
      "explanation": "CDNは世界中のエッジロケーションにコンテンツをキャッシュし、ユーザーに近い場所から配信することで高速化を実現します。\n\n【CDNの仕組み】\n1. オリジンサーバーにコンテンツを配置\n2. 世界中のエッジサーバーにキャッシュ\n3. ユーザーは最寄りのエッジからコンテンツ取得\n4. レイテンシ削減＆オリジン負荷軽減\n\n【他の選択肢】\n・データベースの高速化 → キャッシュDB（Redis等）やインデックス最適化\n・アプリケーションの開発 → 開発ツールやフレームワーク\n・セキュリティの強化 → WAF、ファイアウォール等（CDNも付加機能で提供する場合あり）\n\n【代表的なCDNサービス】\n・Amazon CloudFront、Cloudflare、Akamai、Fastly\n\n【覚え方】\nCDN=Content Delivery Network。「近くから届ける」ことで速くなる",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 51,
      "category": "セキュリティ",
      "question": "公開鍵暗号方式の特徴として正しいものはどれか？",
      "choices": [
        "暗号化と復号に同じ鍵を使用する",
        "共通鍵方式より処理速度が速い",
        "暗号化に公開鍵、復号に秘密鍵を使用する",
        "鍵の配送問題が解決できない"
      ],
      "answer": 2,
      "explanation": "公開鍵暗号方式では、公開鍵で暗号化し、対応する秘密鍵でのみ復号できます。鍵の配送問題を解決できますが、処理速度は共通鍵方式より遅いです。\n\n【暗号方式の比較】\n| 項目 | 共通鍵暗号 | 公開鍵暗号 |\n|------|----------|------------|\n| 鍵の数 | 1つ（共通） | 2つ（公開/秘密） |\n| 処理速度 | 高速 | 低速 |\n| 鍵配送問題 | あり | 解決 |\n| 代表例 | AES, DES | RSA, 楕円曲線 |\n\n【他の選択肢】\n・同じ鍵を使用 → 共通鍵暗号の特徴\n・処理速度が速い → 共通鍵暗号の特徴\n・配送問題が解決できない → 公開鍵暗号で解決\n\n【覚え方】\n公開鍵=「郵便ポスト」。誰でも投函（暗号化）できるが、開ける（復号）のは鍵の持ち主だけ",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 52,
      "category": "セキュリティ",
      "question": "SQLインジェクション攻撃の対策として最も効果的なものはどれか？",
      "choices": [
        "ファイアウォールの導入",
        "プリペアドステートメントの使用",
        "SSLの導入",
        "パスワードの複雑化"
      ],
      "answer": 1,
      "explanation": "プリペアドステートメント（パラメータ化クエリ）を使用することで、SQLインジェクション攻撃を効果的に防ぐことができます。\n\n【SQLインジェクションの仕組み】\n・入力値にSQL文を埋め込み、不正なクエリを実行させる\n・例：' OR '1'='1 でWHERE句を無効化\n\n【対策の優先度】\n1. プリペアドステートメント（最も効果的）\n2. 入力値のエスケープ処理\n3. WAF（Web Application Firewall）\n4. 入力値のバリデーション\n\n【他の選択肢】\n・ファイアウォール → ネットワーク層の防御（アプリ層は防げない）\n・SSL/TLS → 通信の暗号化（攻撃自体は防げない）\n・パスワード複雑化 → 認証の強化（SQLiとは無関係）\n\n【覚え方】\nプリペアドステートメント=「型にはめる」。SQL文とデータを分離して安全に処理",
      "source": {
        "type": "original"
      },
      "difficulty": 3
    },
    {
      "id": 53,
      "category": "セキュリティ",
      "question": "情報セキュリティの三要素（CIA）に含まれないものはどれか？",
      "choices": [
        "機密性（Confidentiality）",
        "完全性（Integrity）",
        "可用性（Availability）",
        "信頼性（Reliability）"
      ],
      "answer": 3,
      "explanation": "CIAは機密性(C)、完全性(I)、可用性(A)の3つです。信頼性は追加の要素として扱われることがあります。\n\n【情報セキュリティの三要素（CIA）】\n・機密性（Confidentiality）：許可された人のみアクセス可能\n・完全性（Integrity）：情報が改ざんされていない\n・可用性（Availability）：必要な時にアクセスできる\n\n【拡張要素】\n・真正性（Authenticity）：本人確認\n・責任追跡性（Accountability）：行動の追跡\n・否認防止（Non-repudiation）：行為の否認を防ぐ\n・信頼性（Reliability）：システムの安定動作\n\n【覚え方】\nCIA=「Cは秘密」「Iは正しい」「Aは使える」。情報セキュリティの基本3原則",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 54,
      "category": "セキュリティ",
      "question": "多要素認証で使用される要素の組み合わせとして正しいものはどれか？",
      "choices": [
        "パスワードと秘密の質問",
        "パスワードとワンタイムパスワード",
        "指紋と顔認証",
        "ICカードとスマートフォン"
      ],
      "answer": 1,
      "explanation": "多要素認証は異なる種類の要素を組み合わせます。パスワード（知識）とOTP（所持）は異なる要素です。同種の要素の組み合わせは多要素認証になりません。\n\n【認証の3要素】\n1. 知識要素（Something you know）：パスワード、PIN、秘密の質問\n2. 所持要素（Something you have）：スマホ、ICカード、OTPトークン\n3. 生体要素（Something you are）：指紋、顔、虹彩\n\n【他の選択肢の分析】\n・パスワード＋秘密の質問 → 両方「知識」要素（×）\n・指紋＋顔認証 → 両方「生体」要素（×）\n・ICカード＋スマホ → 両方「所持」要素（×）\n・パスワード＋OTP → 「知識」＋「所持」（○）\n\n【覚え方】\n多要素=「異なる種類」の組み合わせ。同種2つは「多段階認証」であって多要素ではない",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 55,
      "category": "セキュリティ",
      "question": "XSS（クロスサイトスクリプティング）攻撃の対策として正しいものはどれか？",
      "choices": [
        "入力値のエスケープ処理",
        "ファイアウォールの設置",
        "SSHの使用",
        "RAIDの導入"
      ],
      "answer": 0,
      "explanation": "XSS対策として、出力時にHTMLエスケープ処理を行い、悪意のあるスクリプトが実行されないようにします。\n\n【XSSの種類】\n・反射型XSS：URLパラメータ等を即座に反映\n・格納型XSS：DBに保存されたスクリプトが実行\n・DOMベースXSS：クライアント側で発生\n\n【XSS対策】\n1. 出力時のHTMLエスケープ（< → &lt; 等）\n2. Content-Security-Policy（CSP）ヘッダー\n3. HttpOnly Cookie（JSからアクセス禁止）\n4. 入力値のバリデーション\n\n【他の選択肢】\n・ファイアウォール → ネットワーク層の防御\n・SSH → サーバー接続の暗号化\n・RAID → ストレージ冗長化\n\n【覚え方】\nXSS=「悪意のスクリプトを埋め込む」攻撃。対策は「危険な文字を無害化（エスケープ）」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 56,
      "category": "セキュリティ",
      "question": "ランサムウェアの説明として正しいものはどれか？",
      "choices": [
        "ユーザーの情報を収集して送信するマルウェア",
        "データを暗号化して身代金を要求するマルウェア",
        "正規のソフトウェアに偽装したマルウェア",
        "自己複製してネットワークを通じて拡散するマルウェア"
      ],
      "answer": 1,
      "explanation": "ランサムウェアはデータを暗号化し、復号のために身代金（ランサム）を要求するマルウェアです。\n\n【マルウェアの種類】\n| 種類 | 特徴 |\n|------|------|\n| ランサムウェア | データ暗号化＋身代金要求 |\n| スパイウェア | 情報収集・送信 |\n| トロイの木馬 | 正規ソフトに偽装 |\n| ワーム | 自己複製・ネットワーク拡散 |\n| ウイルス | ファイルに感染・増殖 |\n\n【ランサムウェア対策】\n・定期的なバックアップ（オフライン保管）\n・OSとソフトウェアの更新\n・不審なメール/添付ファイルを開かない\n・セキュリティソフトの導入\n\n【覚え方】\nランサム（Ransom）=「身代金」。データを人質にして金銭を要求する",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 57,
      "category": "セキュリティ",
      "question": "SHA-256の説明として正しいものはどれか？",
      "choices": [
        "共通鍵暗号アルゴリズム",
        "公開鍵暗号アルゴリズム",
        "ハッシュ関数",
        "デジタル署名アルゴリズム"
      ],
      "answer": 2,
      "explanation": "SHA-256は256ビットのハッシュ値を生成する暗号学的ハッシュ関数です。改ざん検知やパスワードの保存などに使用されます。\n\n【暗号技術の分類】\n| 分類 | 用途 | 例 |\n|------|------|----|\n| 共通鍵暗号 | データ暗号化 | AES, DES |\n| 公開鍵暗号 | 鍵交換、署名 | RSA, ECDSA |\n| ハッシュ関数 | 改ざん検知 | SHA-256, MD5 |\n\n【ハッシュ関数の特徴】\n・一方向性：元データに戻せない\n・衝突耐性：同じハッシュ値を持つ別データを作れない\n・固定長出力：入力サイズに関わらず同じ長さ\n\n【他の選択肢】\n・共通鍵暗号 → AES、DES\n・公開鍵暗号 → RSA、楕円曲線暗号\n・デジタル署名 → RSA署名、ECDSA（ハッシュ+公開鍵暗号）\n\n【覚え方】\nSHA=Secure Hash Algorithm。ハッシュは「一方通行」で元に戻せない",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 58,
      "category": "セキュリティ",
      "question": "ゼロトラストセキュリティの考え方として正しいものはどれか？",
      "choices": [
        "内部ネットワークは信頼できる",
        "一度認証すれば以降は信頼する",
        "すべてのアクセスを検証する",
        "ファイアウォールがあれば安全"
      ],
      "answer": 2,
      "explanation": "ゼロトラストは「何も信頼しない」という前提で、すべてのアクセスを常に検証するセキュリティモデルです。\n\n【従来の境界防御 vs ゼロトラスト】\n| 項目 | 境界防御 | ゼロトラスト |\n|------|----------|-------------|\n| 前提 | 内部は信頼 | 何も信頼しない |\n| 検証 | 境界のみ | 常に検証 |\n| 対象 | ネットワーク | ユーザー/デバイス/アプリ |\n\n【ゼロトラストの原則】\n1. Never Trust, Always Verify（常に検証）\n2. 最小権限の原則\n3. 継続的な監視と検証\n4. マイクロセグメンテーション\n\n【他の選択肢】\n・内部NWは信頼 → 従来の境界防御\n・一度認証すれば信頼 → 継続的検証が必要\n・ファイアウォールで安全 → 境界防御の考え方\n\n【覚え方】\nゼロトラスト=「信頼度ゼロ」。誰も信じず、毎回確認する",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 59,
      "category": "セキュリティ",
      "question": "DDoS攻撃の説明として正しいものはどれか？",
      "choices": [
        "単一のコンピュータからサービスを妨害する",
        "多数のコンピュータからサービスを妨害する",
        "データベースを改ざんする",
        "認証情報を盗み取る"
      ],
      "answer": 1,
      "explanation": "DDoS（Distributed Denial of Service）は多数のコンピュータから大量のリクエストを送り、サービスを利用不能にする攻撃です。\n\n【DoS vs DDoS】\n| 項目 | DoS | DDoS |\n|------|-----|------|\n| 攻撃元 | 単一 | 複数（分散） |\n| 規模 | 小〜中 | 大規模 |\n| 対策難易度 | 比較的容易 | 困難 |\n| ボットネット | 不使用 | 使用 |\n\n【DDoSの攻撃手法】\n・SYN Flood：TCP接続を大量に途中放棄\n・UDP Flood：大量のUDPパケットを送信\n・HTTP Flood：正規のHTTPリクエストを大量送信\n・DNS増幅攻撃：DNSを悪用してトラフィック増幅\n\n【対策】\n・CDN/WAFによる防御\n・レート制限\n・DDoS対策サービス（AWS Shield等）\n\n【覚え方】\nDDoS=Distributed（分散）+DoS。「分散型」でより大規模・強力",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 60,
      "category": "セキュリティ",
      "question": "PKI（公開鍵基盤）における認証局（CA）の役割はどれか？",
      "choices": [
        "暗号化を行う",
        "デジタル証明書を発行する",
        "ファイアウォールを管理する",
        "ウイルススキャンを行う"
      ],
      "answer": 1,
      "explanation": "認証局（CA）は公開鍵の所有者を確認し、デジタル証明書を発行する役割を持ちます。\n\n【PKIの構成要素】\n・認証局（CA）：証明書の発行・失効管理\n・登録局（RA）：申請者の本人確認\n・証明書リポジトリ：証明書の保管・公開\n・失効リスト（CRL/OCSP）：無効な証明書の情報\n\n【デジタル証明書に含まれる情報】\n・公開鍵\n・所有者情報（ドメイン名等）\n・発行者（CA）情報\n・有効期限\n・CAの電子署名\n\n【他の選択肢】\n・暗号化を行う → エンドユーザーやアプリケーション\n・ファイアウォール管理 → ネットワーク管理者\n・ウイルススキャン → アンチウイルスソフト\n\n【覚え方】\nCA=Certificate Authority（証明局）。「この公開鍵は本物です」と保証する機関",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 61,
      "category": "DX技術",
      "question": "機械学習における「教師あり学習」の説明として正しいものはどれか？",
      "choices": [
        "正解ラベルなしでデータの構造を学習する",
        "正解ラベル付きデータで学習する",
        "報酬を最大化するように学習する",
        "人間が逐一指示を与えながら学習する"
      ],
      "answer": 1,
      "explanation": "教師あり学習は、正解ラベル（教師データ）付きのデータセットを使って学習する手法です。分類や回帰問題に使用されます。\n\n【機械学習の3つの手法】\n| 手法 | 特徴 | 例 |\n|------|------|----|\n| 教師あり学習 | ラベル付きデータで学習 | 画像分類、スパム判定 |\n| 教師なし学習 | ラベルなしでパターン発見 | クラスタリング |\n| 強化学習 | 報酬を最大化 | ゲームAI、ロボット |\n\n【教師あり学習のタスク】\n・分類（Classification）：カテゴリ分け\n・回帰（Regression）：数値予測\n\n【他の選択肢】\n・ラベルなしでデータ構造学習 → 教師なし学習\n・報酬最大化 → 強化学習\n・逐一指示 → ルールベースシステム\n\n【覚え方】\n教師あり=「正解付きの問題で勉強」。教師（正解ラベル）がいる状態で学習",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 62,
      "category": "DX技術",
      "question": "IoTデバイスの近くでデータ処理を行い、レイテンシを低減する技術は何か？",
      "choices": [
        "クラウドコンピューティング",
        "エッジコンピューティング",
        "グリッドコンピューティング",
        "クラスタコンピューティング"
      ],
      "answer": 1,
      "explanation": "エッジコンピューティングは、データソースの近く（エッジ）で処理を行うことで、レイテンシの低減や帯域幅の節約を実現します。\n\n【エッジ vs クラウド】\n| 項目 | エッジ | クラウド |\n|------|--------|----------|\n| 処理場所 | デバイス近く | 遠隔DC |\n| レイテンシ | 低い | 高い |\n| 帯域使用 | 少ない | 多い |\n| 処理能力 | 限定的 | 大規模 |\n\n【エッジの活用例】\n・自動運転車（即時判断が必要）\n・工場のリアルタイム制御\n・映像解析（全データ送信は非効率）\n\n【他の選択肢】\n・クラウドコンピューティング → 遠隔DCで処理\n・グリッドコンピューティング → 分散リソースの共有\n・クラスタコンピューティング → 複数サーバーの連携\n\n【覚え方】\nエッジ=「端」。データの「端（現場）」で処理→レイテンシ削減",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 63,
      "category": "DX技術",
      "question": "画像認識に特化したディープラーニングのアーキテクチャはどれか？",
      "choices": [
        "RNN",
        "CNN",
        "LSTM",
        "GAN"
      ],
      "answer": 1,
      "explanation": "CNN（畳み込みニューラルネットワーク）は画像認識に特化したアーキテクチャです。RNN/LSTMは時系列データに適しています。\n\n【ディープラーニングのアーキテクチャ】\n| 種類 | 特徴 | 用途 |\n|------|------|------|\n| CNN | 畳み込み層で空間特徴抽出 | 画像認識 |\n| RNN | 過去の情報を保持 | 時系列、テキスト |\n| LSTM | RNNの長期依存問題を解決 | 翻訳、音声 |\n| GAN | 生成器と識別器の対抗学習 | 画像生成 |\n| Transformer | 注意機構で並列処理 | 自然言語処理 |\n\n【CNNの仕組み】\n・畳み込み層：フィルターで特徴抽出\n・プーリング層：情報を圧縮\n・全結合層：最終的な分類\n\n【覚え方】\nCNN=Convolutional（畳み込み）。画像を「畳み込んで」特徴を抽出",
      "source": {
        "type": "original"
      },
      "difficulty": 3
    },
    {
      "id": 64,
      "category": "DX技術",
      "question": "IoT通信プロトコルMQTTの特徴として正しいものはどれか？",
      "choices": [
        "重量級で高機能",
        "軽量でPub/Subモデル",
        "HTTPベースのプロトコル",
        "リアルタイム性がない"
      ],
      "answer": 1,
      "explanation": "MQTTは軽量なPub/Sub（発行/購読）モデルのプロトコルで、IoTデバイスの通信に適しています。\n\n【MQTTの特徴】\n・軽量プロトコル（ヘッダが小さい）\n・Pub/Sub（発行/購読）モデル\n・ブローカーを介した非同期通信\n・QoS（サービス品質）レベル設定可能\n\n【IoT通信プロトコルの比較】\n| プロトコル | 特徴 |\n|-----------|------|\n| MQTT | 軽量、Pub/Sub |\n| CoAP | 軽量、RESTライク |\n| HTTP | 重量、リクエスト/レスポンス |\n| WebSocket | 双方向、リアルタイム |\n\n【他の選択肢】\n・重量級 → HTTP等の従来プロトコル\n・HTTPベース → REST API\n・リアルタイム性なし → バッチ処理\n\n【覚え方】\nMQTT=Message Queuing Telemetry Transport。「軽くてIoT向き」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 65,
      "category": "DX技術",
      "question": "ブロックチェーンにおけるProof of Workの説明として正しいものはどれか？",
      "choices": [
        "保有するコインの量で承認権を得る",
        "計算問題を解くことで承認権を得る",
        "投票によって承認を行う",
        "中央管理者が承認を行う"
      ],
      "answer": 1,
      "explanation": "Proof of Work（PoW）は計算問題を解くことでブロックの承認権を得るコンセンサスアルゴリズムです。Bitcoinで使用されています。\n\n【コンセンサスアルゴリズムの比較】\n| 方式 | 特徴 | 使用例 |\n|------|------|--------|\n| PoW | 計算量で承認 | Bitcoin |\n| PoS | 保有量で承認 | Ethereum 2.0 |\n| DPoS | 代表者による承認 | EOS |\n| PBFT | 投票による承認 | Hyperledger |\n\n【PoWの特徴】\n・大量の計算が必要（マイニング）\n・電力消費が大きい\n・51%攻撃への耐性\n\n【他の選択肢】\n・保有コイン量で承認 → PoS（Proof of Stake）\n・投票による承認 → DPoS、PBFT\n・中央管理者 → 従来の中央集権システム\n\n【覚え方】\nPoW=「働いた（Work）証拠」。計算という「労働」をして承認権を得る",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 66,
      "category": "DX技術",
      "question": "自然言語処理で使用されるTransformerアーキテクチャを採用したモデルはどれか？",
      "choices": [
        "AlexNet",
        "VGG",
        "BERT",
        "ResNet"
      ],
      "answer": 2,
      "explanation": "BERTはTransformerアーキテクチャを採用した自然言語処理モデルです。AlexNet、VGG、ResNetは画像認識用のCNNモデルです。\n\n【Transformerベースのモデル】\n・BERT：双方向エンコーダー、理解タスク向き\n・GPT：一方向デコーダー、生成タスク向き\n・T5：エンコーダー+デコーダー\n\n【画像認識モデル（CNN）】\n| モデル | 特徴 |\n|--------|------|\n| AlexNet | 深層学習ブレイクスルー（2012） |\n| VGG | 層を深くしたシンプル構造 |\n| ResNet | スキップ接続で超深層化 |\n\n【Transformerの特徴】\n・Attention機構で並列処理可能\n・長い文脈を捉えられる\n・2017年「Attention Is All You Need」論文で提案\n\n【覚え方】\nBERT=Bidirectional Encoder。「双方向」に文脈を理解するNLPモデル",
      "source": {
        "type": "original"
      },
      "difficulty": 3
    },
    {
      "id": 67,
      "category": "DX技術",
      "question": "RPAの説明として正しいものはどれか？",
      "choices": [
        "AI技術を使った高度な意思決定システム",
        "定型業務をソフトウェアロボットで自動化する技術",
        "ロボットを使った物流の自動化",
        "ブロックチェーンによる契約の自動化"
      ],
      "answer": 1,
      "explanation": "RPA（Robotic Process Automation）は、定型的なPC操作をソフトウェアロボットで自動化する技術です。\n\n【RPAの適用対象】\n・データ入力、転記作業\n・定型レポート作成\n・システム間のデータ連携\n・メール処理、ファイル操作\n\n【RPAの種類】\n・Attended RPA：人と協働（デスクトップ型）\n・Unattended RPA：完全自動（サーバー型）\n・Hybrid RPA：両方の組み合わせ\n\n【代表的なRPAツール】\n・UiPath、Automation Anywhere、Blue Prism、Power Automate\n\n【他の選択肢】\n・AI意思決定 → AIエージェント、意思決定支援システム\n・物流自動化 → 産業用ロボット、AGV\n・契約自動化 → スマートコントラクト\n\n【覚え方】\nRPA=「ソフトウェアのロボット」。人の代わりにPC操作を自動実行",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 68,
      "category": "DX技術",
      "question": "強化学習の特徴として正しいものはどれか？",
      "choices": [
        "正解ラベル付きデータで学習する",
        "報酬を最大化するように学習する",
        "データの構造を発見する",
        "ルールベースで動作する"
      ],
      "answer": 1,
      "explanation": "強化学習は環境との相互作用から得られる報酬を最大化するように学習する手法です。ゲームAIやロボット制御に使用されます。\n\n【強化学習の要素】\n・エージェント：学習する主体\n・環境：エージェントが行動する場\n・状態：環境の現在の状況\n・行動：エージェントが取る選択\n・報酬：行動の結果得られるフィードバック\n\n【強化学習の例】\n・ゲームAI（囲碁AlphaGo等）\n・ロボット制御\n・自動運転\n・推薦システム\n\n【他の選択肢】\n・正解ラベル付きデータ → 教師あり学習\n・データ構造の発見 → 教師なし学習\n・ルールベース → エキスパートシステム\n\n【覚え方】\n強化学習=「試行錯誤学習」。成功したら報酬、失敗したら罰で学ぶ",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 69,
      "category": "DX技術",
      "question": "NFTの特徴として正しいものはどれか？",
      "choices": [
        "同じ価値のトークンと交換できる",
        "唯一無二で代替不可能なトークン",
        "暗号通貨として使用できる",
        "物理的な形を持つ"
      ],
      "answer": 1,
      "explanation": "NFT（Non-Fungible Token）は唯一無二で代替不可能なデジタル資産を表すトークンです。デジタルアートなどに使用されます。\n\n【Fungible vs Non-Fungible】\n| 種類 | 特徴 | 例 |\n|------|------|----|\n| Fungible | 代替可能 | 暗号通貨、お金 |\n| Non-Fungible | 代替不可能 | デジタルアート、ゲームアイテム |\n\n【NFTの活用例】\n・デジタルアート、音楽\n・ゲーム内アイテム\n・チケット、会員権\n・不動産のデジタル証明\n\n【NFTの技術的特徴】\n・ブロックチェーン上で所有権を記録\n・ERC-721（Ethereum標準）が一般的\n・改ざん不可能な来歴管理\n\n【他の選択肢】\n・交換可能 → 暗号通貨（Fungible Token）\n・暗号通貨として使用 → Bitcoin、Ethereum等\n・物理的形 → 現物資産\n\n【覚え方】\nNFT=Non-Fungible（代替不可）Token。「世界に一つだけ」のデジタル資産",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 70,
      "category": "DX技術",
      "question": "デジタルツインの説明として正しいものはどれか？",
      "choices": [
        "2台のサーバーを使った冗長化",
        "物理世界の対象をデジタル空間に再現",
        "2つのデータセンターによるバックアップ",
        "暗号鍵のペア"
      ],
      "answer": 1,
      "explanation": "デジタルツインは物理世界の対象（機械、建物など）をデジタル空間に仮想的に再現し、シミュレーションや予測に活用する技術です。\n\n【デジタルツインの活用例】\n・製造業：設備の故障予測、生産最適化\n・建設：ビルのエネルギー管理\n・医療：臓器モデルによる治療計画\n・都市計画：交通流シミュレーション\n\n【デジタルツインの構成要素】\n・物理世界のセンサーデータ\n・リアルタイムデータ連携\n・仮想モデル（3Dモデル等）\n・シミュレーション・分析エンジン\n\n【他の選択肢】\n・2台サーバー冗長化 → クラスタリング、HA構成\n・2DC間バックアップ → ディザスタリカバリ\n・暗号鍵ペア → 公開鍵暗号\n\n【覚え方】\nデジタルツイン=「デジタルの双子」。現実世界の「双子」をデジタル空間に作る",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 71,
      "category": "DX利活用",
      "question": "ビッグデータの特性を表す「3V」に含まれないものはどれか？",
      "choices": [
        "Volume（量）",
        "Velocity（速度）",
        "Variety（多様性）",
        "Value（価値）"
      ],
      "answer": 3,
      "explanation": "ビッグデータの3VはVolume（データ量）、Velocity（生成・処理速度）、Variety（データの多様性）です。Valueは後から追加された概念です。\n\n【ビッグデータの3V（基本）】\n・Volume：ペタバイト級の大量データ\n・Velocity：リアルタイムで生成・処理\n・Variety：構造化/非構造化、多様な形式\n\n【追加のV（拡張概念）】\n・Veracity：データの正確性・信頼性\n・Value：データから得られる価値\n\n【ビッグデータの活用例】\n・マーケティング分析\n・需要予測\n・異常検知\n・パーソナライゼーション\n\n【覚え方】\n3V=「量・速度・多様性」。ビッグデータは単に量が多いだけでなく、速く多様",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 72,
      "category": "DX利活用",
      "question": "DXの定義における「デジタル技術による変革」の対象として適切でないものはどれか？",
      "choices": [
        "ビジネスモデル",
        "業務プロセス",
        "企業文化",
        "オフィスの内装"
      ],
      "answer": 3,
      "explanation": "DXはビジネスモデル、業務プロセス、企業文化・風土などの変革を対象とします。物理的な内装は直接的なDXの対象ではありません。\n\n【DXの変革対象】\n・ビジネスモデル：収益構造、顧客価値の創造方法\n・業務プロセス：業務フローの効率化、自動化\n・企業文化：データドリブン、アジャイルな組織へ\n・顧客体験：CX（カスタマーエクスペリエンス）向上\n\n【DXの3段階】\n1. デジタイゼーション：アナログ→デジタル化\n2. デジタライゼーション：プロセスのデジタル化\n3. DX：ビジネス全体の変革\n\n【他の選択肢】\n・ビジネスモデル → 変革の核心\n・業務プロセス → 効率化・自動化の対象\n・企業文化 → DX成功の重要要素\n\n【覚え方】\nDX=「デジタルでビジネスを変える」。内装などの物理的変更はDXではない",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 73,
      "category": "DX利活用",
      "question": "KPIとKGIの関係として正しいものはどれか？",
      "choices": [
        "KPIはKGIを達成するための中間指標",
        "KGIはKPIを達成するための中間指標",
        "KPIとKGIは同じものを指す",
        "KPIは財務指標、KGIは非財務指標"
      ],
      "answer": 0,
      "explanation": "KGI（重要目標達成指標）が最終目標、KPI（重要業績評価指標）はKGIを達成するための中間指標です。\n\n【KGIとKPIの関係】\n| 指標 | 意味 | 例 |\n|------|------|----|\n| KGI | 最終目標 | 売上10億円達成 |\n| KPI | 中間指標 | 月間訪問数、成約率 |\n\n【設定のポイント】\n・KGI→KPIの順で設定\n・KPIはSMART原則（具体的、測定可能、達成可能、関連性、期限）\n・1つのKGIに複数のKPI\n\n【関連用語】\n・CSF（重要成功要因）：KGI達成に必要な要素\n・OKR：目標と主要成果（より野心的な目標設定）\n\n【他の選択肢】\n・KGIはKPIの中間指標 → 逆（KPIがKGIの中間指標）\n・同じもの → 明確に異なる\n・財務/非財務 → どちらも両方含みうる\n\n【覚え方】\nKGI=Goal（ゴール）、KPI=Performance（途中経過）。「最終目標」と「途中の指標」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 74,
      "category": "DX利活用",
      "question": "アジャイル開発のフレームワーク「スクラム」における「スプリント」とは何か？",
      "choices": [
        "プロジェクト全体の期間",
        "1〜4週間程度の開発サイクル",
        "毎朝行うミーティング",
        "製品の最終リリース"
      ],
      "answer": 1,
      "explanation": "スプリントは1〜4週間程度の固定された開発サイクルです。各スプリントでリリース可能な成果物を作成します。\n\n【スクラムのイベント】\n| イベント | 内容 | タイミング |\n|----------|------|------------|\n| スプリント | 開発サイクル | 1-4週間 |\n| スプリント計画 | 作業の計画 | スプリント開始時 |\n| デイリースクラム | 進捗共有 | 毎日15分 |\n| スプリントレビュー | 成果物デモ | スプリント終了時 |\n| レトロスペクティブ | 振り返り | スプリント終了時 |\n\n【スクラムの3つの役割】\n・プロダクトオーナー：要件の優先順位決定\n・スクラムマスター：プロセスの促進・障害除去\n・開発チーム：自己組織化されたチーム\n\n【他の選択肢】\n・プロジェクト全体期間 → スプリントは短い反復\n・毎朝のミーティング → デイリースクラム\n・最終リリース → リリースは複数スプリント後も可能\n\n【覚え方】\nスプリント=「短距離走」。短期間で集中して成果を出す",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 75,
      "category": "DX利活用",
      "question": "プロジェクト管理においてWBSが表すものはどれか？",
      "choices": [
        "リスク一覧",
        "作業の階層的分解構造",
        "スケジュール表",
        "コスト見積り"
      ],
      "answer": 1,
      "explanation": "WBS（Work Breakdown Structure）は成果物や作業を階層的に分解した構造図で、プロジェクトの全体像を把握するのに使用します。\n\n【WBSの階層構造例】\nプロジェクト\n├─ フェーズ1：要件定義\n│  ├─ ヒアリング\n│  └─ 要件書作成\n├─ フェーズ2：設計\n│  ├─ 基本設計\n│  └─ 詳細設計\n└─ フェーズ3：開発...\n\n【WBSの目的】\n・作業の洗い出し漏れ防止\n・スケジュール、コスト見積りの基礎\n・責任範囲の明確化\n・進捗管理の単位\n\n【関連ドキュメント】\n・ガントチャート：WBSをスケジュール表に展開\n・PERT図：作業の順序関係を表現\n\n【他の選択肢】\n・リスク一覧 → リスク登録簿\n・スケジュール表 → ガントチャート\n・コスト見積り → 見積書\n\n【覚え方】\nWBS=Work Breakdown（作業分解）Structure（構造）。「作業を分解して構造化」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 76,
      "category": "DX利活用",
      "question": "IT調達における「請負契約」の特徴として正しいものはどれか？",
      "choices": [
        "作業時間に対して報酬が支払われる",
        "成果物の完成に対して報酬が支払われる",
        "労働者派遣と同じ形態",
        "発注者が作業を直接指示できる"
      ],
      "answer": 1,
      "explanation": "請負契約は成果物の完成に対して報酬が支払われる契約形態で、ベンダーが完成責任を負います。\n\n【IT契約形態の比較】\n| 契約形態 | 報酬基準 | 完成責任 | 指揮命令 |\n|----------|----------|----------|----------|\n| 請負契約 | 成果物 | ベンダー | ベンダー |\n| 準委任契約 | 作業遂行 | なし | ベンダー |\n| 派遣契約 | 労働時間 | なし | 発注者 |\n\n【請負契約の特徴】\n・瑕疵担保責任（契約不適合責任）あり\n・成果物の仕様を明確にする必要\n・追加要件には別途見積りが必要\n\n【適用場面】\n・システム開発、Webサイト制作など\n・成果物が明確に定義できる場合\n\n【他の選択肢】\n・作業時間で報酬 → 準委任契約\n・派遣と同じ → 派遣は発注者が指揮命令\n・直接指示 → 偽装請負になる（違法）\n\n【覚え方】\n請負=「成果物を請け負う」。完成させる責任がある",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 77,
      "category": "DX利活用",
      "question": "PoC（Proof of Concept）の目的として正しいものはどれか？",
      "choices": [
        "本番環境での運用",
        "概念や技術の実現可能性を検証",
        "ユーザーへのサービス提供",
        "製品の量産"
      ],
      "answer": 1,
      "explanation": "PoCは新しい概念や技術が実現可能かどうかを検証するための実証実験です。本格導入前に行います。\n\n【PoCのプロセス】\n1. 仮説設定：検証したい内容を明確化\n2. 最小限の実装：必要最低限の機能で構築\n3. 検証：期待通りの結果が得られるか確認\n4. 評価：本格導入の可否を判断\n\n【PoCの目的】\n・技術的実現可能性の確認\n・リスクの早期発見\n・投資判断の材料\n・ステークホルダーへのデモ\n\n【関連用語】\n・MVP：実用最小限の製品（市場検証用）\n・パイロット：小規模な本番運用\n・プロトタイプ：試作品\n\n【他の選択肢】\n・本番運用 → PoCは検証段階\n・ユーザーへのサービス提供 → 本番フェーズ\n・製品の量産 → 製造フェーズ\n\n【覚え方】\nPoC=Proof of Concept（概念実証）。「本当にできる？」を試す段階",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 78,
      "category": "DX利活用",
      "question": "「2025年の崖」問題で指摘されている課題はどれか？",
      "choices": [
        "AI技術者の不足",
        "レガシーシステムの維持・刷新の困難さ",
        "5G通信の普及遅れ",
        "クラウドサービスの価格高騰"
      ],
      "answer": 1,
      "explanation": "「2025年の崖」はレガシーシステムの老朽化・複雑化により、2025年以降に最大12兆円の経済損失が生じる可能性を指摘したものです。\n\n【2025年の崖の問題点】\n・老朽化したシステムの維持コスト増大\n・システムのブラックボックス化\n・IT人材の退職（高齢化）\n・サポート終了（Windows Server 2008等）\n\n【経済産業省DXレポートの指摘】\n・2025年までにシステム刷新しないと最大12兆円/年の損失\n・IT予算の8割が維持運用に費やされる\n・データ活用ができずDXが進まない\n\n【対策】\n・レガシーシステムの刷新・モダナイゼーション\n・クラウドへの移行\n・内製化・アジャイル開発の推進\n\n【他の選択肢】\n・AI技術者不足 → 別の課題（ただし関連はある）\n・5G普及遅れ → インフラ課題\n・クラウド価格 → 逆にコスト削減につながる\n\n【覚え方】\n2025年の崖=「レガシーを放置すると2025年に崖から落ちる」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 79,
      "category": "DX利活用",
      "question": "GDPRはどの地域のデータ保護規則か？",
      "choices": [
        "日本",
        "アメリカ",
        "EU",
        "中国"
      ],
      "answer": 2,
      "explanation": "GDPR（General Data Protection Regulation）はEUの一般データ保護規則で、個人データの保護を規定しています。\n\n【GDPRの主な権利】\n・アクセス権：自分のデータを確認する権利\n・訂正権：誤ったデータを修正する権利\n・削除権（忘れられる権利）：データ削除を求める権利\n・ポータビリティ権：データを別サービスに移行する権利\n\n【GDPRの適用範囲】\n・EU内の組織\n・EU居住者にサービス提供する組織（日本企業も対象）\n\n【違反時の制裁金】\n・最大2000万ユーロまたは売上高の4％\n\n【各国のデータ保護法】\n・日本：個人情報保護法\n・アメリカ：CCPA（カリフォルニア州）\n・中国：個人情報保護法\n\n【他の選択肢】\n・日本 → 個人情報保護法\n・アメリカ → 統一法なし（州法が中心）\n・中国 → 個人情報保護法、サイバーセキュリティ法\n\n【覚え方】\nGDPR=EUのデータ保護法。日本企業もEU向けサービスなら対象",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 80,
      "category": "DX利活用",
      "question": "ローコード/ノーコード開発の特徴として正しいものはどれか？",
      "choices": [
        "高度なプログラミングスキルが必要",
        "最小限のコーディングでアプリケーションを開発できる",
        "実行速度が従来の開発より高速",
        "大規模システムに最適"
      ],
      "answer": 1,
      "explanation": "ローコード/ノーコード開発は、視覚的なインターフェースを使用し、最小限のコーディングでアプリケーションを開発できる手法です。\n\n【ローコード vs ノーコード】\n| 項目 | ローコード | ノーコード |\n|------|-----------|------------|\n| コーディング | 最小限必要 | 不要 |\n| 対象者 | 開発者・IT担当 | 業務担当者 |\n| カスタマイズ性 | 高い | 限定的 |\n\n【代表的なツール】\n・ローコード：OutSystems、Mendix、Power Apps\n・ノーコード：Bubble、Airtable、Notion\n\n【メリット】\n・開発スピード向上\n・IT人材不足への対応\n・市民開発者の活用\n\n【デメリット】\n・複雑な処理には限界\n・ベンダーロックイン\n・大規模システムには不向き\n\n【他の選択肢】\n・高度なスキル必要 → 逆にスキル不要が特徴\n・実行速度が高速 → 必ずしも高速ではない\n・大規模に最適 → 小〜中規模向け\n\n【覚え方】\nローコード=「コード少なめ」、ノーコード=「コード不要」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 81,
      "category": "インフラストラクチャ",
      "question": "VLANの主な目的として正しいものはどれか？",
      "choices": [
        "物理的なネットワーク機器を削減する",
        "論理的にネットワークを分割する",
        "インターネット接続速度を向上させる",
        "無線LANのセキュリティを強化する"
      ],
      "answer": 1,
      "explanation": "VLAN（Virtual LAN）は物理的な接続に関係なく、論理的にネットワークを分割する技術です。\n\n【VLANのメリット】\n・セキュリティ向上：部門間の通信を制限できる\n・ブロードキャストドメインの分割：不要な通信を削減\n・柔軟な構成：物理的な配線変更なしでネットワーク変更可能\n\n【他の選択肢】\n・物理機器の削減 → VLANは論理分割であり、物理機器削減が主目的ではない\n・インターネット速度向上 → VLANの主目的ではない\n・無線LANセキュリティ → 無線LANに限定されない",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 82,
      "category": "インフラストラクチャ",
      "question": "UPSの主な役割として正しいものはどれか？",
      "choices": [
        "ネットワークの負荷分散",
        "停電時の電源供給",
        "データのバックアップ",
        "サーバーの冷却"
      ],
      "answer": 1,
      "explanation": "UPS（Uninterruptible Power Supply：無停電電源装置）は停電時にバッテリーから電力を供給します。\n\n【UPSの役割】\n・停電時の電源供給：サーバーを安全にシャットダウンする時間を確保\n・電圧変動からの保護：サージやノイズから機器を保護\n・瞬断対策：短時間の停電でもシステムを継続稼働\n\n【他の選択肢】\n・負荷分散 → ロードバランサーの役割\n・バックアップ → バックアップソフト/ストレージの役割\n・冷却 → 空調設備の役割",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 83,
      "category": "インフラストラクチャ",
      "question": "RAID0の特徴として正しいものはどれか？",
      "choices": [
        "ミラーリングにより冗長性を確保する",
        "パリティにより1台の障害に耐えられる",
        "ストライピングにより高速だが冗長性がない",
        "最低4台のディスクが必要"
      ],
      "answer": 2,
      "explanation": "RAID0はストライピングによりデータを分散書き込みするため高速ですが、冗長性がなく1台でも故障するとデータが失われます。\n\n【RAID0の特徴】\n・複数ディスクに分散書き込み（ストライピング）\n・読み書き速度が向上\n・冗長性ゼロ：1台故障で全データ消失\n・最低2台から構成可能\n\n【他の選択肢】\n・ミラーリング → RAID1の特徴\n・パリティ → RAID5/6の特徴\n・最低4台 → RAID6は4台以上、RAID0は2台から",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 84,
      "category": "インフラストラクチャ",
      "question": "IPv6アドレスのビット長はどれか？",
      "choices": [
        "32ビット",
        "64ビット",
        "128ビット",
        "256ビット"
      ],
      "answer": 2,
      "explanation": "IPv6アドレスは128ビットで、IPv4の32ビットに比べて大幅に拡張されています。\n\n【IPv4 vs IPv6】\n・IPv4：32ビット、約43億アドレス（枯渇問題）\n・IPv6：128ビット、約340澗（かん）アドレス（事実上無限）\n\n【IPv6の表記例】\n2001:0db8:85a3:0000:0000:8a2e:0370:7334\n（16進数、コロン区切り）\n\n【覚え方】\nIPv4=32、IPv6=128（32×4=128）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 85,
      "category": "インフラストラクチャ",
      "question": "ロードバランサーの機能として正しいものはどれか？",
      "choices": [
        "データの暗号化",
        "複数サーバーへのトラフィック分散",
        "ウイルスの検出",
        "ファイルの圧縮"
      ],
      "answer": 1,
      "explanation": "ロードバランサーは、複数のサーバーにトラフィックを分散させ、負荷を均等化し可用性を高める装置です。\n\n【主な分散方式】\n・ラウンドロビン：順番に振り分け\n・最小接続：接続数が少ないサーバーへ\n・IPハッシュ：同一クライアントを同一サーバーへ\n\n【他の選択肢】\n・データ暗号化 → SSL/TLSの役割（※SSL終端は可能）\n・ウイルス検出 → セキュリティソフトの役割\n・ファイル圧縮 → 圧縮ソフトの役割",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 86,
      "category": "インフラストラクチャ",
      "question": "DHCPの役割として正しいものはどれか？",
      "choices": [
        "ドメイン名をIPアドレスに変換する",
        "IPアドレスを自動的に割り当てる",
        "メールを転送する",
        "Webページを配信する"
      ],
      "answer": 1,
      "explanation": "DHCP（Dynamic Host Configuration Protocol）は、ネットワーク機器にIPアドレスなどの設定を自動的に割り当てるプロトコルです。\n\n【DHCPが割り当てる情報】\n・IPアドレス\n・サブネットマスク\n・デフォルトゲートウェイ\n・DNSサーバーアドレス\n\n【他の選択肢】\n・ドメイン名→IP変換 → DNS（Domain Name System）の役割\n・メール転送 → SMTP（Simple Mail Transfer Protocol）の役割\n・Webページ配信 → HTTP/HTTPSの役割",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 87,
      "category": "インフラストラクチャ",
      "question": "SAN（Storage Area Network）の特徴として正しいものはどれか？",
      "choices": [
        "ファイル単位でアクセスする",
        "ブロック単位で高速アクセスする",
        "インターネット経由でアクセスする",
        "USBで直接接続する"
      ],
      "answer": 1,
      "explanation": "SANはブロック単位でアクセスする高速なストレージネットワークで、ファイバーチャネルやiSCSIで接続されます。\n\n【ストレージの比較】\n・SAN：ブロック単位、高速、専用ネットワーク（FC/iSCSI）\n・NAS：ファイル単位、導入容易、汎用ネットワーク（NFS/SMB）\n・DAS：直接接続、サーバー専用\n\n【他の選択肢】\n・ファイル単位 → NASの特徴\n・インターネット経由 → クラウドストレージの特徴\n・USB接続 → DASの一種",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 88,
      "category": "インフラストラクチャ",
      "question": "ARPの役割として正しいものはどれか？",
      "choices": [
        "IPアドレスからMACアドレスを取得する",
        "MACアドレスからIPアドレスを取得する",
        "ドメイン名からIPアドレスを取得する",
        "ポート番号からプロトコルを特定する"
      ],
      "answer": 0,
      "explanation": "ARP（Address Resolution Protocol）は、IPアドレスから対応するMACアドレスを取得するプロトコルです。\n\n【ARPの動作】\n1. ARPリクエストをブロードキャスト送信\n2. 該当IPを持つ機器がMACアドレスを返答\n3. ARPテーブルにキャッシュ\n\n【関連プロトコル】\n・RARP：MACアドレス → IPアドレス（逆方向）\n・DNS：ドメイン名 → IPアドレス\n\n【他の選択肢】\n・MAC→IP → RARPの役割\n・ドメイン→IP → DNSの役割",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 89,
      "category": "インフラストラクチャ",
      "question": "クラスBのプライベートIPアドレス範囲として正しいものはどれか？",
      "choices": [
        "10.0.0.0 ～ 10.255.255.255",
        "172.16.0.0 ～ 172.31.255.255",
        "192.168.0.0 ～ 192.168.255.255",
        "169.254.0.0 ～ 169.254.255.255"
      ],
      "answer": 1,
      "explanation": "クラスBのプライベートIPアドレスは172.16.0.0～172.31.255.255です。\n\n【プライベートIPアドレス一覧】\n・クラスA：10.0.0.0 ～ 10.255.255.255（10.0.0.0/8）\n・クラスB：172.16.0.0 ～ 172.31.255.255（172.16.0.0/12）\n・クラスC：192.168.0.0 ～ 192.168.255.255（192.168.0.0/16）\n\n【他の選択肢】\n・169.254.x.x → リンクローカルアドレス（APIPA）\n　DHCPが使えない時に自動割り当てされる特殊なアドレス",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 90,
      "category": "インフラストラクチャ",
      "question": "TCPとUDPの違いとして正しいものはどれか？",
      "choices": [
        "TCPは高速だが信頼性が低い",
        "UDPはコネクション型プロトコル",
        "TCPは再送制御を行う",
        "UDPは順序制御を行う"
      ],
      "answer": 2,
      "explanation": "TCPはコネクション型で再送制御や順序制御を行い信頼性が高いです。UDPはコネクションレス型で高速ですが信頼性は低いです。\n\n【TCP vs UDP】\n| 項目 | TCP | UDP |\n|------|-----|-----|\n| 接続方式 | コネクション型 | コネクションレス型 |\n| 信頼性 | 高い | 低い |\n| 速度 | 遅い | 速い |\n| 再送制御 | あり | なし |\n| 用途 | HTTP、メール | DNS、動画配信 |\n\n【他の選択肢が不正解の理由】\n・TCPは信頼性が高い（低いのはUDP）\n・UDPはコネクションレス型\n・UDPは順序制御を行わない",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 91,
      "category": "インフラストラクチャ",
      "question": "HTTPSで使用されるポート番号はどれか？",
      "choices": [
        "80",
        "443",
        "8080",
        "8443"
      ],
      "answer": 1,
      "explanation": "HTTPSはポート443を使用します。HTTPにSSL/TLSによる暗号化を加えたプロトコルです。\n\n【Web関連ポート番号】\n・80：HTTP（暗号化なし）\n・443：HTTPS（暗号化あり）\n・8080：HTTPの代替ポート（開発用など）\n・8443：HTTPSの代替ポート\n\n【HTTPSの特徴】\n・通信内容を暗号化\n・サーバー証明書により正当性を確認\n・現在のWebサイトでは標準",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 92,
      "category": "インフラストラクチャ",
      "question": "NATの主な目的として正しいものはどれか？",
      "choices": [
        "通信を暗号化する",
        "プライベートIPをグローバルIPに変換する",
        "ドメイン名を解決する",
        "メールを転送する"
      ],
      "answer": 1,
      "explanation": "NAT（Network Address Translation）は、プライベートIPアドレスとグローバルIPアドレスを相互変換する技術です。\n\n【NATの種類】\n・静的NAT：1対1で固定変換\n・動的NAT：プールから動的に割り当て\n・NAPT（PAT）：ポート番号も変換し、1つのグローバルIPを複数で共有\n\n【NATのメリット】\n・グローバルIPアドレスの節約\n・内部ネットワーク構成を隠蔽\n\n【他の選択肢】\n・暗号化 → SSL/TLS/VPNの役割\n・ドメイン解決 → DNSの役割",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 93,
      "category": "インフラストラクチャ",
      "question": "RAID6の特徴として正しいものはどれか？",
      "choices": [
        "1台のディスク障害に耐えられる",
        "2台のディスク障害に耐えられる",
        "冗長性がない",
        "最低2台のディスクで構成できる"
      ],
      "answer": 1,
      "explanation": "RAID6はパリティを2重に持つため、同時に2台のディスクが故障してもデータを復元できます。\n\n【RAIDレベル比較】\n| RAID | 耐障害 | 最低台数 | 特徴 |\n|------|--------|----------|------|\n| 0 | 0台 | 2台 | 高速、冗長性なし |\n| 1 | 1台 | 2台 | ミラーリング |\n| 5 | 1台 | 3台 | パリティ分散 |\n| 6 | 2台 | 4台 | 2重パリティ |\n\n【実務ポイント】\nRAID6はRAID5より安全ですが、書き込み性能は低下します。大容量ディスクでの再構築時間を考慮し、RAID6が選ばれることが増えています。",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 94,
      "category": "インフラストラクチャ",
      "question": "SMTPが使用するポート番号はどれか？",
      "choices": [
        "22",
        "25",
        "110",
        "143"
      ],
      "answer": 1,
      "explanation": "SMTPはポート25を使用するメール送信プロトコルです。\n\n【メール関連プロトコル】\n・SMTP（25）：メール送信（サーバー間転送）\n・SMTPS（465/587）：暗号化メール送信\n・POP3（110）：メール受信（ダウンロード型）\n・IMAP（143）：メール受信（サーバー管理型）\n\n【POP3 vs IMAP】\n・POP3：メールをダウンロードして削除\n・IMAP：サーバーにメールを残し同期",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 95,
      "category": "インフラストラクチャ",
      "question": "ホットスタンバイの特徴として正しいものはどれか？",
      "choices": [
        "障害時に手動で切り替える",
        "予備系が常時稼働し即座に切り替わる",
        "予備系は電源が切れている",
        "最も低コストな冗長化方式"
      ],
      "answer": 1,
      "explanation": "ホットスタンバイは予備系が常時稼働しており、障害発生時に即座に切り替わる方式です。\n\n【冗長化方式の比較】\n| 方式 | 予備系状態 | 切替時間 | コスト |\n|------|------------|----------|--------|\n| コールドスタンバイ | 電源OFF | 長い | 低 |\n| ウォームスタンバイ | 起動済み | 中程度 | 中 |\n| ホットスタンバイ | 常時稼働 | 即座 | 高 |\n\n【他の選択肢】\n・手動切り替え → コールドスタンバイの特徴\n・電源OFF → コールドスタンバイの特徴\n・低コスト → コールドスタンバイの特徴",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 96,
      "category": "OS・ミドルウェア",
      "question": "Linuxでファイルの所有者を変更するコマンドはどれか？",
      "choices": [
        "chmod",
        "chown",
        "chgrp",
        "chattr"
      ],
      "answer": 1,
      "explanation": "chownはファイルやディレクトリの所有者を変更するコマンドです。\n\n【chownの使い方】\n・chown user file：所有者を変更\n・chown user:group file：所有者とグループを同時に変更\n・chown -R user dir：再帰的に変更\n\n【他の選択肢】\n・chmod：権限（パーミッション）を変更\n・chgrp：グループのみ変更\n・chattr：ファイル属性を変更（immutable等）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 97,
      "category": "OS・ミドルウェア",
      "question": "Linuxのログファイルが格納されるディレクトリはどれか？",
      "choices": [
        "/etc",
        "/var/log",
        "/usr/log",
        "/home/log"
      ],
      "answer": 1,
      "explanation": "/var/logディレクトリにはシステムやアプリケーションのログファイルが格納されます。\n\n【主なログファイル】\n・/var/log/messages または syslog：システム全般\n・/var/log/auth.log：認証ログ\n・/var/log/secure：セキュリティログ（RHEL系）\n・/var/log/apache2/：Apacheログ\n・/var/log/nginx/：Nginxログ\n\n【他の選択肢】\n・/etc：設定ファイル\n・/usr/log：存在しない\n・/home/log：存在しない",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 98,
      "category": "OS・ミドルウェア",
      "question": "プロセスとスレッドの違いとして正しいものはどれか？",
      "choices": [
        "スレッドは独自のメモリ空間を持つ",
        "プロセスはメモリ空間を共有する",
        "スレッドは同一プロセス内でメモリを共有する",
        "プロセスはスレッドより軽量"
      ],
      "answer": 2,
      "explanation": "スレッドは同一プロセス内でメモリ空間を共有します。プロセスは独立したメモリ空間を持ちます。\n\n【プロセス vs スレッド】\n| 項目 | プロセス | スレッド |\n|------|----------|----------|\n| メモリ | 独立 | 共有 |\n| 生成コスト | 高い | 低い |\n| 切替コスト | 高い | 低い |\n| 安全性 | 高い | 競合注意 |\n\n【他の選択肢が不正解の理由】\n・スレッドは独自メモリを持たない\n・プロセスはメモリを共有しない\n・プロセスはスレッドより重い",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 99,
      "category": "OS・ミドルウェア",
      "question": "Linuxで現在のディレクトリを表示するコマンドはどれか？",
      "choices": [
        "cd",
        "pwd",
        "ls",
        "dir"
      ],
      "answer": 1,
      "explanation": "pwdコマンドは現在の作業ディレクトリのパスを表示します。\n\n【基本的なディレクトリ操作コマンド】\n・pwd：現在位置を表示（Print Working Directory）\n・cd：ディレクトリ移動（Change Directory）\n・ls：ファイル一覧表示（List）\n・mkdir：ディレクトリ作成\n・rmdir：空ディレクトリ削除\n\n【覚え方】\npwd = Print Working Directory（作業ディレクトリを表示）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 100,
      "category": "OS・ミドルウェア",
      "question": "仮想メモリの説明として正しいものはどれか？",
      "choices": [
        "RAMの一部を高速キャッシュとして使用する",
        "ディスク領域をメモリの拡張として使用する",
        "複数のCPUでメモリを共有する",
        "ネットワーク経由でメモリを共有する"
      ],
      "answer": 1,
      "explanation": "仮想メモリはディスク領域を利用して物理メモリを拡張する仕組みです。\n\n【仮想メモリの仕組み】\n・物理メモリ（RAM）が不足したとき、ディスクにデータを退避\n・Linuxではスワップ領域（swap）として設定\n・Windowsではページファイル（pagefile.sys）\n\n【メリット】\n・物理メモリより大きなプログラムを実行可能\n・メモリ保護とプロセス分離\n\n【デメリット】\n・ディスクアクセスはRAMより大幅に遅い",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 101,
      "category": "OS・ミドルウェア",
      "question": "Linuxでファイルを検索するコマンドはどれか？",
      "choices": [
        "grep",
        "find",
        "locate",
        "search"
      ],
      "answer": 1,
      "explanation": "findコマンドはファイル名やディレクトリを検索します。\n\n【検索コマンドの違い】\n・find：ファイル名・属性で検索（リアルタイム）\n・locate：ファイル名で高速検索（DB利用）\n・grep：ファイル内容を検索\n・which：コマンドのパスを検索\n\n【findの使用例】\n・find /home -name \"*.txt\"：.txtファイルを検索\n・find . -mtime -7：7日以内に更新されたファイル\n・find . -size +100M：100MB以上のファイル",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 102,
      "category": "OS・ミドルウェア",
      "question": "systemdの役割として正しいものはどれか？",
      "choices": [
        "ファイルシステムの管理",
        "システムとサービスの管理",
        "ネットワークの設定",
        "パッケージの管理"
      ],
      "answer": 1,
      "explanation": "systemdはLinuxのシステム・サービス管理デーモンで、起動処理やサービスの制御を行います。\n\n【systemctlコマンド】\n・systemctl start サービス名：起動\n・systemctl stop サービス名：停止\n・systemctl enable サービス名：自動起動有効\n・systemctl status サービス名：状態確認\n\n【他の選択肢】\n・ファイルシステム管理 → mount, fdisk等\n・ネットワーク設定 → ip, nmcli等\n・パッケージ管理 → apt, yum等",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 103,
      "category": "OS・ミドルウェア",
      "question": "Linuxのパーミッション「644」の意味として正しいものはどれか？",
      "choices": [
        "所有者：読取書込、グループ：読取、その他：読取",
        "所有者：全権限、グループ：読取実行、その他：読取実行",
        "所有者：読取実行、グループ：書込、その他：書込",
        "所有者：読取、グループ：書込実行、その他：書込実行"
      ],
      "answer": 0,
      "explanation": "644は所有者がrw-(6)、グループがr--(4)、その他がr--(4)を意味します。\n\n【644の計算】\n・6 = 4+2+0 = rw-（読取と書込）\n・4 = 4+0+0 = r--（読取のみ）\n・4 = 4+0+0 = r--（読取のみ）\n\n【よく使うパーミッション】\n・644：一般ファイル（所有者のみ編集可能）\n・755：実行ファイル・ディレクトリ\n・600：秘密ファイル（所有者のみアクセス）\n・777：全員に全権限（セキュリティ上非推奨）",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 104,
      "category": "OS・ミドルウェア",
      "question": "メッセージキューイングの代表的なミドルウェアはどれか？",
      "choices": [
        "Apache",
        "RabbitMQ",
        "MySQL",
        "Redis"
      ],
      "answer": 1,
      "explanation": "RabbitMQはメッセージキューイングの代表的なミドルウェアです。非同期通信やシステム間連携に使用されます。\n\n【メッセージキューイングの用途】\n・非同期処理：即時応答が不要な処理を後回し\n・負荷分散：複数ワーカーで処理を分担\n・システム連携：異なるシステム間のデータ受け渡し\n\n【代表的なMQ製品】\n・RabbitMQ、Apache Kafka、Amazon SQS、ActiveMQ\n\n【他の選択肢】\n・Apache：Webサーバー\n・MySQL：データベース\n・Redis：インメモリDB/キャッシュ",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 105,
      "category": "OS・ミドルウェア",
      "question": "Linuxでプロセスを強制終了するシグナルはどれか？",
      "choices": [
        "SIGHUP",
        "SIGTERM",
        "SIGKILL",
        "SIGINT"
      ],
      "answer": 2,
      "explanation": "SIGKILL（シグナル9）はプロセスを強制終了するシグナルで、プロセスはこのシグナルを無視できません。\n\n【主なシグナル】\n| シグナル | 番号 | 動作 |\n|----------|------|------|\n| SIGHUP | 1 | 設定再読み込み |\n| SIGINT | 2 | 割り込み（Ctrl+C） |\n| SIGTERM | 15 | 終了要求（無視可能） |\n| SIGKILL | 9 | 強制終了（無視不可） |\n\n【使い方】\n・kill -9 PID：強制終了\n・kill -15 PID：正常終了要求（デフォルト）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 106,
      "category": "OS・ミドルウェア",
      "question": "Linuxでディスク使用量を確認するコマンドはどれか？",
      "choices": [
        "df",
        "du",
        "free",
        "top"
      ],
      "answer": 0,
      "explanation": "dfコマンドはファイルシステムのディスク使用量を表示します。\n\n【ディスク・メモリ確認コマンド】\n・df：ファイルシステム全体の使用量\n・df -h：人間が読みやすい形式で表示\n・du：ディレクトリ/ファイルごとの使用量\n・du -sh dir：ディレクトリの合計サイズ\n・free：メモリ使用量\n・top：リアルタイムでリソース監視\n\n【覚え方】\ndf = disk free（空き容量）\ndu = disk usage（使用量）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 107,
      "category": "OS・ミドルウェア",
      "question": "LVMの特徴として正しいものはどれか？",
      "choices": [
        "RAIDの一種である",
        "論理ボリュームを柔軟に管理できる",
        "ファイルシステムの一種である",
        "ネットワークストレージ技術である"
      ],
      "answer": 1,
      "explanation": "LVM（Logical Volume Manager）は論理ボリュームを柔軟に作成・拡張・縮小できるディスク管理技術です。\n\n【LVMの構成要素】\n・PV（Physical Volume）：物理ディスク\n・VG（Volume Group）：PVの集合\n・LV（Logical Volume）：VGから切り出した論理領域\n\n【LVMのメリット】\n・稼働中にボリュームサイズを変更可能\n・複数ディスクを1つの領域として管理\n・スナップショット作成が可能\n\n【他の選択肢】\n・RAIDは冗長性技術、LVMは管理技術",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 108,
      "category": "OS・ミドルウェア",
      "question": "RHEL/CentOS系Linuxでパッケージを管理するコマンドはどれか？",
      "choices": [
        "apt",
        "yum",
        "pacman",
        "brew"
      ],
      "answer": 1,
      "explanation": "yum（およびdnf）はRHEL/CentOS系Linuxで使用されるパッケージ管理コマンドです。\n\n【パッケージ管理コマンド比較】\n| ディストリ | コマンド |\n|------------|----------|\n| RHEL/CentOS 7以前 | yum |\n| RHEL/CentOS 8以降 | dnf |\n| Debian/Ubuntu | apt |\n| Arch Linux | pacman |\n| macOS | brew（非標準） |\n\n【yum/dnfの主なコマンド】\n・yum install：インストール\n・yum update：更新\n・yum remove：削除\n・yum search：検索",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 109,
      "category": "OS・ミドルウェア",
      "question": "Linuxでネットワーク設定を確認するコマンドはどれか？",
      "choices": [
        "netstat",
        "ip addr",
        "route",
        "ping"
      ],
      "answer": 1,
      "explanation": "ip addrコマンドはネットワークインターフェースのIPアドレス設定を確認できます。従来のifconfigの代替です。\n\n【ネットワーク確認コマンド】\n・ip addr（ip a）：IPアドレス確認\n・ip route（ip r）：ルーティング確認\n・ss：ソケット/接続確認（netstat代替）\n・ping：疎通確認\n\n【他の選択肢】\n・netstat：接続状況確認（旧式、ssを推奨）\n・route：ルーティング確認（旧式）\n・ping：疎通確認（設定確認ではない）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 110,
      "category": "OS・ミドルウェア",
      "question": "リバースプロキシの役割として正しいものはどれか？",
      "choices": [
        "クライアントの代理としてインターネットにアクセスする",
        "サーバーの代理としてクライアントからのリクエストを受ける",
        "DNSの名前解決を行う",
        "メールを転送する"
      ],
      "answer": 1,
      "explanation": "リバースプロキシはサーバー側に配置され、クライアントからのリクエストを受けて背後のサーバーに転送します。\n\n【プロキシの種類】\n・フォワードプロキシ：クライアント側に配置、クライアントの代理\n・リバースプロキシ：サーバー側に配置、サーバーの代理\n\n【リバースプロキシの用途】\n・負荷分散（ロードバランサー）\n・SSL終端（暗号化処理の集約）\n・キャッシュ（静的コンテンツの配信）\n・セキュリティ（WAF、バックエンド隠蔽）\n\n【代表的な製品】\nNginx、HAProxy、Apache",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 111,
      "category": "データベース",
      "question": "主キーの特徴として正しいものはどれか？",
      "choices": [
        "NULL値を許容する",
        "重複した値を許容する",
        "一意でありNULLを許容しない",
        "外部キーと同じ意味である"
      ],
      "answer": 2,
      "explanation": "主キーはテーブル内で各行を一意に識別するため、重複とNULL値は許容されません。\n\n【主キーの特徴】\n・一意性：重複した値を持てない\n・非NULL：NULL値を持てない\n・1テーブルに1つのみ定義可能\n・自動的にインデックスが作成される\n\n【関連する制約】\n・UNIQUE：一意性のみ（NULLは許可）\n・NOT NULL：非NULLのみ（重複は許可）\n・外部キー：他テーブルとの参照関係",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 112,
      "category": "データベース",
      "question": "外部キーの役割として正しいものはどれか？",
      "choices": [
        "テーブル内の行を一意に識別する",
        "他のテーブルとの参照整合性を保つ",
        "インデックスを自動作成する",
        "データを暗号化する"
      ],
      "answer": 1,
      "explanation": "外部キーは他のテーブルの主キーを参照し、テーブル間の参照整合性を維持します。\n\n【外部キーの役割】\n・参照整合性の保証：親テーブルに存在しないデータを防止\n・カスケード操作：親データ削除時に子データも削除可能\n\n【例】\n注文テーブルの顧客ID → 顧客テーブルの顧客ID\n（存在しない顧客への注文を防止）\n\n【他の選択肢】\n・行の一意識別 → 主キーの役割\n・インデックス自動作成 → 主キーの特徴（外部キーは任意）",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 113,
      "category": "データベース",
      "question": "LEFT JOINの説明として正しいものはどれか？",
      "choices": [
        "両方のテーブルで一致するレコードのみを返す",
        "左テーブルの全レコードと一致する右テーブルのレコードを返す",
        "右テーブルの全レコードと一致する左テーブルのレコードを返す",
        "両方のテーブルの全レコードを返す"
      ],
      "answer": 1,
      "explanation": "LEFT JOIN（LEFT OUTER JOIN）は左テーブルの全レコードを返し、右テーブルは一致するものがあれば結合、なければNULLになります。\n\n【JOINの動作】\n・INNER JOIN：A ∩ B（共通部分のみ）\n・LEFT JOIN：A + (A ∩ B)（左は全て、右は一致のみ）\n・RIGHT JOIN：(A ∩ B) + B（左は一致のみ、右は全て）\n・FULL OUTER JOIN：A ∪ B（両方全て）\n\n【使用例】\n全顧客と注文履歴を取得（注文なしの顧客も含む）\n→ LEFT JOIN",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 114,
      "category": "データベース",
      "question": "トランザクションの独立性（Isolation）を保証するものはどれか？",
      "choices": [
        "ロック機構",
        "ログ機構",
        "バックアップ",
        "レプリケーション"
      ],
      "answer": 0,
      "explanation": "ロック機構により、複数のトランザクションが同時に同じデータにアクセスする際の干渉を防ぎ、独立性を保証します。\n\n【ロックの種類】\n・共有ロック（Sロック）：読み取り用、複数可\n・排他ロック（Xロック）：書き込み用、1つのみ\n\n【他の選択肢】\n・ログ機構 → 永続性(D)を保証（コミット後の復旧）\n・バックアップ → 障害復旧用\n・レプリケーション → 可用性向上\n\n【分離レベル】\nREAD UNCOMMITTED < READ COMMITTED < REPEATABLE READ < SERIALIZABLE",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 115,
      "category": "データベース",
      "question": "ビューの特徴として正しいものはどれか？",
      "choices": [
        "物理的にデータを格納する",
        "仮想的なテーブルとして機能する",
        "インデックスを持つ",
        "トリガーを設定できない"
      ],
      "answer": 1,
      "explanation": "ビューは実際のテーブルに基づく仮想的なテーブルで、複雑なクエリの簡略化やセキュリティに使用されます。\n\n【ビューの用途】\n・複雑なクエリの簡略化\n・セキュリティ：必要な列のみ公開\n・論理的独立性：テーブル構造変更の影響を軽減\n\n【他の選択肢】\n・物理的データ格納 → ビューはクエリ定義のみ保存\n・インデックス → マテリアライズドビューは持てる場合あり\n・トリガー → ビューにも設定可能なDBMSあり\n\n【作成例】\nCREATE VIEW active_users AS\nSELECT * FROM users WHERE status = 'active';",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 116,
      "category": "データベース",
      "question": "MongoDBの分類として正しいものはどれか？",
      "choices": [
        "リレーショナルデータベース",
        "ドキュメント指向データベース",
        "グラフデータベース",
        "キー・バリュー型データベース"
      ],
      "answer": 1,
      "explanation": "MongoDBはJSONライクなドキュメントを格納するドキュメント指向のNoSQLデータベースです。\n\n【MongoDBの特徴】\n・BSON（Binary JSON）形式でデータ格納\n・スキーマレス：柔軟なデータ構造\n・水平スケーリング（シャーディング）対応\n・レプリカセットによる高可用性\n\n【NoSQLの分類と代表例】\n・ドキュメント型：MongoDB、CouchDB\n・キー・バリュー型：Redis、Memcached\n・グラフ型：Neo4j\n・カラム指向型：Cassandra",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 117,
      "category": "データベース",
      "question": "SQLのDISTINCTの役割として正しいものはどれか？",
      "choices": [
        "NULL値を除外する",
        "重複した行を除外する",
        "昇順で並べ替える",
        "先頭の行のみを取得する"
      ],
      "answer": 1,
      "explanation": "DISTINCTは重複した行を除外し、一意の結果のみを返します。\n\n【使用例】\nSELECT DISTINCT department FROM employees;\n（重複なしで部署名を取得）\n\n【他の選択肢】\n・NULLを除外 → WHERE col IS NOT NULL\n・昇順並べ替え → ORDER BY col ASC\n・先頭行のみ → LIMIT 1 / TOP 1\n\n【注意点】\n・DISTINCTは全列の組み合わせで重複判定\n・パフォーマンスに影響するため必要な場合のみ使用",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 118,
      "category": "データベース",
      "question": "ストアドプロシージャの特徴として正しいものはどれか？",
      "choices": [
        "クライアント側で実行される",
        "データベースサーバー側で実行される",
        "トランザクション制御ができない",
        "パラメータを受け取れない"
      ],
      "answer": 1,
      "explanation": "ストアドプロシージャはデータベースサーバー側で実行されるプログラムで、複雑な処理やトランザクション制御が可能です。\n\n【ストアドプロシージャのメリット】\n・ネットワーク通信量の削減\n・処理のカプセル化とセキュリティ向上\n・複雑なビジネスロジックの集約\n・コンパイル済みで高速実行\n\n【他の選択肢】\n・クライアント実行 → サーバー側で実行\n・トランザクション不可 → 制御可能\n・パラメータ不可 → 受け取り可能",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 119,
      "category": "データベース",
      "question": "マスター・スレーブレプリケーションの特徴として正しいものはどれか？",
      "choices": [
        "全ノードで書き込みが可能",
        "マスターで書き込み、スレーブで読み取り",
        "データの分散格納",
        "自動フェイルオーバー"
      ],
      "answer": 1,
      "explanation": "マスター・スレーブレプリケーションはマスターノードで書き込みを行い、スレーブノードにデータを複製して読み取り負荷を分散します。\n\n【レプリケーションの構成】\n・マスター：書き込み担当（1台）\n・スレーブ：読み取り担当（複数台可）\n\n【他の選択肢】\n・全ノードで書き込み → マルチマスター構成\n・データ分散格納 → シャーディング\n・自動フェイルオーバー → 別途設定が必要\n\n【注意点】\n・同期遅延（レプリケーションラグ）が発生する可能性\n・最新の用語では「プライマリ/レプリカ」と呼ぶことも",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 120,
      "category": "データベース",
      "question": "B-treeインデックスが効果的なクエリはどれか？",
      "choices": [
        "LIKE '%keyword%'",
        "等価条件と範囲検索",
        "全文検索",
        "空間検索"
      ],
      "answer": 1,
      "explanation": "B-treeインデックスは等価条件（=）や範囲検索（<, >, BETWEEN）に効果的です。\n\n【B-treeが効果的なケース】\n・等価条件：WHERE id = 100\n・範囲検索：WHERE age BETWEEN 20 AND 30\n・前方一致：WHERE name LIKE 'A%'\n・ORDER BY句\n\n【B-treeが効かないケース】\n・中間/後方一致：LIKE '%keyword%'\n・全文検索 → 全文検索インデックスを使用\n・空間検索 → R-treeなどを使用\n\n【他のインデックス種類】\nハッシュインデックス、GiSTなど",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 121,
      "category": "データベース",
      "question": "Redisの特徴として正しいものはどれか？",
      "choices": [
        "ディスクベースのRDBMS",
        "インメモリ型のキー・バリューストア",
        "ドキュメント指向データベース",
        "グラフデータベース"
      ],
      "answer": 1,
      "explanation": "Redisはインメモリ型のキー・バリューストアで、高速なデータアクセスが可能です。\n\n【Redisの特徴】\n・インメモリ：全データをメモリに保持（高速）\n・永続化オプション：RDB/AOFでディスク保存可能\n・豊富なデータ型：文字列、リスト、ハッシュ、セット等\n\n【主な用途】\n・キャッシュ\n・セッション管理\n・リアルタイムランキング\n・Pub/Subメッセージング\n\n【類似製品】\nMemcached（よりシンプル、データ型が少ない）",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 122,
      "category": "データベース",
      "question": "SQLのUNION ALLとUNIONの違いとして正しいものはどれか？",
      "choices": [
        "UNION ALLは重複を除外する",
        "UNIONは重複を除外する",
        "UNION ALLは列数が異なっても結合できる",
        "UNIONは異なるテーブルを結合できない"
      ],
      "answer": 1,
      "explanation": "UNIONは重複行を除外して結合しますが、UNION ALLは重複を含めてすべての行を結合します。\n\n【UNION vs UNION ALL】\n・UNION：重複除外（DISTINCTと同様の処理）\n・UNION ALL：重複を含む（高速）\n\n【使用例】\nSELECT name FROM table1\nUNION ALL\nSELECT name FROM table2;\n\n【注意点】\n・両方とも列数とデータ型が一致する必要あり\n・重複が不要ならUNION ALL（パフォーマンス良好）\n・重複除外が必要ならUNION",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 123,
      "category": "データベース",
      "question": "第2正規形の条件として正しいものはどれか？",
      "choices": [
        "繰り返し項目がないこと",
        "部分関数従属がないこと",
        "推移関数従属がないこと",
        "多値従属性がないこと"
      ],
      "answer": 1,
      "explanation": "第2正規形は第1正規形を満たし、かつ部分関数従属がない（非キー属性が主キー全体に完全従属する）ことが条件です。\n\n【正規形の段階】\n・第1正規形：繰り返し項目がない\n・第2正規形：部分関数従属がない\n・第3正規形：推移関数従属がない\n\n【部分関数従属の例】\n複合キー（注文ID, 商品ID）に対して\n商品名が商品IDのみに依存\n→ 商品テーブルを分離して第2正規形へ\n\n【注意】\n単一の主キーなら第1正規形＝第2正規形",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 124,
      "category": "データベース",
      "question": "楽観的ロックの特徴として正しいものはどれか？",
      "choices": [
        "データ読み取り時にロックを取得する",
        "更新時にバージョンをチェックする",
        "同時実行性が低い",
        "デッドロックが発生しやすい"
      ],
      "answer": 1,
      "explanation": "楽観的ロックはロックを取得せず、更新時にバージョン番号やタイムスタンプで競合を検出します。\n\n【楽観的ロック vs 悲観的ロック】\n| 項目 | 楽観的 | 悲観的 |\n|------|--------|--------|\n| ロック | しない | する |\n| 競合検出 | 更新時 | 読取時 |\n| 同時実行性 | 高い | 低い |\n| 競合時 | リトライ | 待機 |\n\n【実装方法】\n・バージョン番号：version列で管理\n・タイムスタンプ：更新日時で管理\n・ハッシュ値：データのハッシュで比較",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 125,
      "category": "データベース",
      "question": "シャーディングの目的として正しいものはどれか？",
      "choices": [
        "データのバックアップ",
        "データの水平分割による拡張",
        "データの暗号化",
        "データの圧縮"
      ],
      "answer": 1,
      "explanation": "シャーディングはデータを複数のデータベースに水平分割し、負荷分散とスケーラビリティを向上させる手法です。\n\n【シャーディングの仕組み】\n・シャードキーに基づいてデータを分散配置\n・例：ユーザーID 1-1000万→DB1、1000万-2000万→DB2\n\n【シャーディング vs レプリケーション】\n・シャーディング：データを分割（スケールアウト）\n・レプリケーション：データを複製（可用性向上）\n\n【他の選択肢】\n・バックアップ → 障害復旧用\n・暗号化 → セキュリティ対策\n・圧縮 → ストレージ節約",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 126,
      "category": "アプリケーション",
      "question": "マイクロサービスアーキテクチャの特徴として正しいものはどれか？",
      "choices": [
        "モノリシックな単一アプリケーション",
        "小さな独立したサービスの集合",
        "データベースを共有する",
        "同期通信のみを使用する"
      ],
      "answer": 1,
      "explanation": "マイクロサービスは小さな独立したサービスの集合で、各サービスが独自のデータストアを持ち、独立してデプロイできます。\n\n【マイクロサービスの特徴】\n・各サービスが独立してデプロイ可能\n・サービスごとに異なる技術スタックを選択可能\n・各サービスが独自のデータベースを持つ\n・API（REST/gRPC）で通信\n\n【モノリス vs マイクロサービス】\n・モノリス：単一アプリ、シンプル、スケールは全体\n・マイクロサービス：独立サービス、複雑、個別スケール",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 127,
      "category": "アプリケーション",
      "question": "デザインパターンのSingletonの目的はどれか？",
      "choices": [
        "オブジェクトの生成を抽象化する",
        "インスタンスを1つに制限する",
        "オブジェクトの構造を定義する",
        "アルゴリズムを切り替える"
      ],
      "answer": 1,
      "explanation": "Singletonパターンはクラスのインスタンスを1つに制限し、グローバルなアクセスポイントを提供するパターンです。\n\n【GoFデザインパターンの分類】\n・生成：Singleton、Factory、Builder等\n・構造：Adapter、Decorator、Facade等\n・振る舞い：Observer、Strategy、Command等\n\n【他の選択肢】\n・オブジェクト生成の抽象化 → Factory\n・オブジェクトの構造を定義 → Composite\n・アルゴリズムを切り替え → Strategy",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 128,
      "category": "アプリケーション",
      "question": "HTTPステータスコード404が意味するものはどれか？",
      "choices": [
        "リクエスト成功",
        "リダイレクト",
        "リソースが見つからない",
        "サーバー内部エラー"
      ],
      "answer": 2,
      "explanation": "404 Not Foundは要求されたリソースがサーバーに存在しないことを示すステータスコードです。\n\n【主要HTTPステータスコード】\n・1xx：情報\n・2xx：成功（200 OK、201 Created）\n・3xx：リダイレクト（301 Moved、302 Found）\n・4xx：クライアントエラー（400 Bad Request、401 Unauthorized、403 Forbidden、404 Not Found）\n・5xx：サーバーエラー（500 Internal、503 Unavailable）\n\n【覚え方】\n4xx = クライアント側の問題、5xx = サーバー側の問題",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 129,
      "category": "アプリケーション",
      "question": "SOLIDの原則のうち「S」が意味するものはどれか？",
      "choices": [
        "開放閉鎖の原則",
        "単一責任の原則",
        "リスコフの置換原則",
        "依存性逆転の原則"
      ],
      "answer": 1,
      "explanation": "SはSingle Responsibility Principle（単一責任の原則）で、クラスは1つの責任のみを持つべきという原則です。\n\n【SOLID原則】\n・S（Single Responsibility）：単一責任の原則\n・O（Open/Closed）：開放閉鎖の原則\n・L（Liskov Substitution）：リスコフの置換原則\n・I（Interface Segregation）：インターフェース分離の原則\n・D（Dependency Inversion）：依存性逆転の原則\n\n【単一責任の原則】\nクラスを変更する理由は1つであるべき（複数の責任を持たない）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 130,
      "category": "アプリケーション",
      "question": "Docker Composeの用途として正しいものはどれか？",
      "choices": [
        "単一コンテナのビルド",
        "複数コンテナの定義と実行",
        "コンテナイメージの配布",
        "コンテナのオーケストレーション"
      ],
      "answer": 1,
      "explanation": "Docker Composeは複数のコンテナをYAMLファイルで定義し、一括して起動・管理するためのツールです。\n\n【Dockerツールの使い分け】\n・Docker：単一コンテナのビルド・実行\n・Docker Compose：複数コンテナの定義・実行（開発環境向け）\n・Docker Hub：コンテナイメージの公開・配布\n・Kubernetes：大規模オーケストレーション（本番環境向け）\n\n【docker-compose.yml例】\nservices:\n  web:\n    image: nginx\n  db:\n    image: mysql",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 131,
      "category": "アプリケーション",
      "question": "GraphQLの特徴として正しいものはどれか？",
      "choices": [
        "固定されたエンドポイントとレスポンス",
        "クライアントが必要なデータを指定できる",
        "RESTより通信回数が多い",
        "HTTPメソッドに依存する"
      ],
      "answer": 1,
      "explanation": "GraphQLはクライアントが必要なデータ構造を指定してクエリを送信し、過不足ないレスポンスを取得できます。\n\n【GraphQL vs REST】\n・GraphQL：1エンドポイント、必要なデータのみ取得、型定義あり\n・REST：複数エンドポイント、固定レスポンス、HTTPメソッドで操作\n\n【GraphQLのメリット】\n・オーバーフェッチ/アンダーフェッチの解消\n・複数リソースを1リクエストで取得\n・型システムによる開発体験向上",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 132,
      "category": "アプリケーション",
      "question": "WebSocketの特徴として正しいものはどれか？",
      "choices": [
        "リクエスト・レスポンス型の通信",
        "双方向のリアルタイム通信",
        "HTTPより接続コストが高い",
        "ステートレスな通信"
      ],
      "answer": 1,
      "explanation": "WebSocketは一度接続を確立すると、サーバーとクライアント間で双方向のリアルタイム通信が可能になります。\n\n【WebSocketの特徴】\n・HTTPハンドシェイク後に接続を維持\n・双方向通信（サーバーからプッシュ可能）\n・リアルタイム性が高い\n・オーバーヘッドが少ない\n\n【用途】\n・チャットアプリ\n・リアルタイム通知\n・オンラインゲーム\n・株価/為替のリアルタイム表示",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 133,
      "category": "アプリケーション",
      "question": "JWTの構成要素として正しいものはどれか？",
      "choices": [
        "ユーザー名とパスワード",
        "ヘッダー、ペイロード、署名",
        "公開鍵と秘密鍵",
        "セッションIDとタイムスタンプ"
      ],
      "answer": 1,
      "explanation": "JWT（JSON Web Token）はヘッダー、ペイロード（データ）、署名の3つの部分で構成されています。\n\n【JWTの構造】\nxxxxx.yyyyy.zzzzz（ドットで区切られた3部分）\n・ヘッダー：アルゴリズム情報（alg: HS256等）\n・ペイロード：ユーザー情報やクレーム\n・署名：改ざん検証用\n\n【JWTの特徴】\n・ステートレス（サーバーでセッション不要）\n・Base64エンコード（暗号化ではない）\n・署名で改ざん検知可能",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 134,
      "category": "アプリケーション",
      "question": "HTTPステータスコード500が意味するものはどれか？",
      "choices": [
        "リクエスト成功",
        "認証が必要",
        "リソースが見つからない",
        "サーバー内部エラー"
      ],
      "answer": 3,
      "explanation": "500 Internal Server Errorはサーバー側で予期しないエラーが発生したことを示すステータスコードです。\n\n【5xx系エラー（サーバーエラー）】\n・500 Internal Server Error：サーバー内部エラー\n・502 Bad Gateway：ゲートウェイエラー\n・503 Service Unavailable：サービス利用不可\n・504 Gateway Timeout：ゲートウェイタイムアウト\n\n【デバッグのポイント】\n・500エラー：サーバーログを確認\n・502/504：上流サーバーの問題を確認",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 135,
      "category": "アプリケーション",
      "question": "Gitでブランチを作成して切り替えるコマンドはどれか？",
      "choices": [
        "git branch",
        "git checkout -b",
        "git merge",
        "git switch"
      ],
      "answer": 1,
      "explanation": "git checkout -bはブランチの作成と切り替えを同時に行います。\n\n【ブランチ操作コマンド】\n・git branch：ブランチ一覧表示\n・git branch 名前：ブランチ作成のみ\n・git checkout -b 名前：作成＋切り替え\n・git switch -c 名前：作成＋切り替え（新しい方法）\n・git checkout 名前：既存ブランチに切り替え\n・git merge 名前：ブランチを統合\n\n【補足】\ngit switchはgit 2.23で導入された新しいコマンドで、checkoutより意図が明確です。",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 136,
      "category": "アプリケーション",
      "question": "CORSの目的として正しいものはどれか？",
      "choices": [
        "データの暗号化",
        "異なるオリジン間のリソース共有を制御",
        "認証情報の保護",
        "セッションの管理"
      ],
      "answer": 1,
      "explanation": "CORS（Cross-Origin Resource Sharing）は異なるオリジン間でのリソースアクセスを安全に制御する仕組みです。\n\n【オリジンとは】\nプロトコル + ドメイン + ポートの組み合わせ\n例：https://example.com:443\n\n【CORSの仕組み】\n・ブラウザが異なるオリジンへのリクエストを検知\n・サーバーがAccess-Control-Allow-Originヘッダーで許可を返す\n・プリフライトリクエスト（OPTIONS）で事前確認\n\n【セキュリティ】\n同一オリジンポリシーを緩和しつつ、安全性を確保",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 137,
      "category": "アプリケーション",
      "question": "OAuth 2.0のアクセストークンの目的はどれか？",
      "choices": [
        "ユーザーの認証",
        "保護されたリソースへのアクセス許可",
        "パスワードの暗号化",
        "セッションの維持"
      ],
      "answer": 1,
      "explanation": "OAuth 2.0のアクセストークンは、クライアントが保護されたリソースにアクセスするための認可情報を表します。\n\n【OAuth 2.0の主要な概念】\n・認可（Authorization）：リソースへのアクセス許可\n・認証（Authentication）：ユーザーの本人確認\n・アクセストークン：リソースアクセス用（有効期限短い）\n・リフレッシュトークン：アクセストークン更新用\n\n【認証 vs 認可】\n・認証：「誰か」を確認（ログイン）\n・認可：「何ができるか」を許可（権限付与）\nOAuth 2.0は認可のためのプロトコルです。",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 138,
      "category": "アプリケーション",
      "question": "継続的デリバリー（CD）と継続的デプロイメントの違いは何か？",
      "choices": [
        "継続的デプロイメントは手動承認が必要",
        "継続的デリバリーは自動で本番にデプロイ",
        "継続的デプロイメントは自動で本番にデプロイ",
        "両者に違いはない"
      ],
      "answer": 2,
      "explanation": "継続的デリバリーはリリース可能な状態を維持し手動承認後にデプロイ、継続的デプロイメントは自動で本番環境にデプロイします。\n\n【CI/CDの段階】\n・CI（継続的インテグレーション）：ビルド・テストの自動化\n・継続的デリバリー：本番デプロイ可能な状態を維持（手動承認）\n・継続的デプロイメント：本番デプロイまで完全自動化\n\n【使い分け】\n・リスク管理が必要 → 継続的デリバリー（承認プロセス）\n・高速リリースが必要 → 継続的デプロイメント（完全自動）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 139,
      "category": "アプリケーション",
      "question": "二分探索の計算量として正しいものはどれか？",
      "choices": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n²)"
      ],
      "answer": 1,
      "explanation": "二分探索はソート済み配列を対象に、毎回半分に絞り込むためO(log n)の計算量になります。\n\n【主要な計算量】\n・O(1)：定数時間（配列の添字アクセス）\n・O(log n)：対数時間（二分探索）\n・O(n)：線形時間（線形探索）\n・O(n log n)：マージソート、クイックソート\n・O(n²)：バブルソート、2重ループ\n\n【二分探索の条件】\n・データがソート済みであること\n・ランダムアクセス可能（配列など）",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 140,
      "category": "アプリケーション",
      "question": "APIのバージョニング方法として一般的でないものはどれか？",
      "choices": [
        "URLパスに含める",
        "クエリパラメータで指定",
        "HTTPヘッダーで指定",
        "Cookie で指定"
      ],
      "answer": 3,
      "explanation": "APIのバージョニングはURLパス、クエリパラメータ、HTTPヘッダーで行うのが一般的です。Cookieは使用しません。\n\n【バージョニング方法】\n・URLパス：/v1/users（最も一般的）\n・クエリパラメータ：/users?version=1\n・HTTPヘッダー：Accept: application/vnd.api.v1+json\n・カスタムヘッダー：X-API-Version: 1\n\n【選択のポイント】\n・URLパス：わかりやすい、キャッシュしやすい\n・ヘッダー：URLがきれい、バージョン変更が柔軟",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 141,
      "category": "クラウド",
      "question": "AWSのS3の特徴として正しいものはどれか？",
      "choices": [
        "仮想サーバーサービス",
        "オブジェクトストレージサービス",
        "リレーショナルデータベースサービス",
        "コンテナオーケストレーションサービス"
      ],
      "answer": 1,
      "explanation": "S3（Simple Storage Service）はオブジェクトストレージサービスで、ファイルを格納・取得できます。\n\n【S3の特徴】\n・オブジェクトストレージ（キー・バリュー型）\n・99.999999999%（イレブンナイン）の耐久性\n・無制限のストレージ容量\n・バージョニング、暗号化対応\n・静的Webサイトホスティング可能\n\n【他の選択肢】\n・仮想サーバー → EC2\n・リレーショナルDB → RDS\n・コンテナオーケストレーション → ECS/EKS\n\n【AWSストレージサービス】\n・S3：オブジェクトストレージ\n・EBS：ブロックストレージ（EC2用）\n・EFS：ファイルストレージ（共有ファイルシステム）\n\n【覚え方】\nS3=Simple Storage Service（3つのS）。「バケット」にオブジェクトを入れる",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 142,
      "category": "クラウド",
      "question": "オートスケーリングの目的として正しいものはどれか？",
      "choices": [
        "セキュリティの強化",
        "負荷に応じてリソースを自動調整",
        "データのバックアップ",
        "ネットワークの最適化"
      ],
      "answer": 1,
      "explanation": "オートスケーリングは負荷の増減に応じてサーバー台数を自動的に増減させ、コスト最適化と可用性を両立させます。\n\n【オートスケーリングの種類】\n・水平スケーリング（スケールアウト/イン）：台数を増減\n・垂直スケーリング（スケールアップ/ダウン）：1台のスペックを変更\n\n【設定項目】\n・最小/最大インスタンス数\n・スケーリングポリシー（CPU使用率等）\n・クールダウン期間\n\n【他の選択肢】\n・セキュリティ強化 → WAF、Security Group等\n・データバックアップ → S3、スナップショット\n・ネットワーク最適化 → CloudFront、Route 53\n\n【覚え方】\n「需要に応じて自動伸縮」。忙しい時は増やし、暇な時は減らす＝コスト最適化",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 143,
      "category": "クラウド",
      "question": "AWS Lambdaの課金単位として正しいものはどれか？",
      "choices": [
        "時間単位",
        "リクエスト数と実行時間",
        "データ転送量のみ",
        "月額固定"
      ],
      "answer": 1,
      "explanation": "AWS Lambdaはリクエスト数と実行時間（メモリ使用量×実行時間）に基づいて課金されます。\n\n【Lambda課金の仕組み】\n・リクエスト数：100万リクエストあたり$0.20\n・実行時間：GB-秒単位（メモリ×秒数）\n・無料枠：月100万リクエスト、40万GB-秒\n\n【他の選択肢】\n・時間単位 → EC2の課金方式\n・データ転送量のみ → S3等のデータ転送課金\n・月額固定 → サブスクリプション型\n\n【サーバーレス課金の特徴】\n・使った分だけ課金\n・待機時間は無料\n・短時間・高頻度の処理に最適\n\n【覚え方】\nLambda=「使った分だけ」。実行しないと0円、実行時間に比例して課金",
      "source": {
        "type": "original"
      },
      "difficulty": 1
    },
    {
      "id": 144,
      "category": "クラウド",
      "question": "クラウドネイティブアプリケーションの特徴として正しいものはどれか？",
      "choices": [
        "オンプレミス環境専用に設計",
        "コンテナ化やマイクロサービス化されている",
        "モノリシックなアーキテクチャ",
        "手動スケーリングを前提"
      ],
      "answer": 1,
      "explanation": "クラウドネイティブはコンテナ、マイクロサービス、DevOpsなどを活用し、クラウド環境の利点を最大限に活かす設計思想です。\n\n【クラウドネイティブの4要素（CNCF定義）】\n1. コンテナ：アプリを軽量にパッケージ化\n2. マイクロサービス：小さなサービスに分割\n3. 動的オーケストレーション：Kubernetes等\n4. 継続的デリバリー：CI/CD\n\n【他の選択肢】\n・オンプレ専用設計 → 従来型アプリ\n・モノリシック → 一枚岩のアーキテクチャ\n・手動スケーリング → クラウドネイティブは自動化が前提\n\n【クラウドネイティブの利点】\n・スケーラビリティ、耐障害性\n・開発・デプロイの高速化\n・リソースの効率的利用\n\n【覚え方】\nネイティブ=「生まれながらの」。クラウド前提で設計されたアプリ",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 145,
      "category": "クラウド",
      "question": "AWS VPCの目的として正しいものはどれか？",
      "choices": [
        "仮想サーバーの作成",
        "論理的に分離されたネットワークの構築",
        "オブジェクトストレージの提供",
        "コンテナの実行"
      ],
      "answer": 1,
      "explanation": "VPC（Virtual Private Cloud）はAWS上に論理的に分離されたプライベートネットワークを構築するサービスです。\n\n【VPCの構成要素】\n・サブネット：VPC内のネットワーク分割（パブリック/プライベート）\n・インターネットゲートウェイ：インターネット接続\n・NATゲートウェイ：プライベートサブネットの外部通信\n・ルートテーブル：通信経路の定義\n・セキュリティグループ：インスタンス単位のFW\n・ネットワークACL：サブネット単位のFW\n\n【他の選択肢】\n・仮想サーバー → EC2\n・オブジェクトストレージ → S3\n・コンテナ実行 → ECS/EKS\n\n【覚え方】\nVPC=仮想の「自分専用ネットワーク」。他のユーザーとは論理的に分離されている",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 146,
      "category": "クラウド",
      "question": "Blue-Greenデプロイメントの特徴として正しいものはどれか？",
      "choices": [
        "段階的にトラフィックを移行する",
        "2つの同一環境を用意し瞬時に切り替える",
        "一部のユーザーにのみ新機能を公開",
        "ロールバックができない"
      ],
      "answer": 1,
      "explanation": "Blue-Greenデプロイメントは本番環境（Blue）と同一構成の新環境（Green）を用意し、切り替えることでダウンタイムなくデプロイできます。\n\n【デプロイ手法の比較】\n| 手法 | 特徴 |\n|------|------|\n| Blue-Green | 2環境用意、瞬時切り替え |\n| カナリア | 一部ユーザーに段階的展開 |\n| ローリング | 順次インスタンスを更新 |\n| A/Bテスト | 機能比較のための2バージョン並行 |\n\n【Blue-Greenのメリット】\n・ダウンタイムほぼゼロ\n・問題時は即座にロールバック可能\n・本番同等環境でテスト可能\n\n【デメリット】\n・リソースが2倍必要\n\n【覚え方】\nBlue=現行、Green=新規。トラフィックを「青→緑」に切り替えるだけ",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 147,
      "category": "クラウド",
      "question": "Kubernetes のServiceの役割として正しいものはどれか？",
      "choices": [
        "コンテナイメージの保存",
        "Podへの安定したアクセスを提供",
        "ノードの管理",
        "ログの収集"
      ],
      "answer": 1,
      "explanation": "KubernetesのServiceはPodへの安定したアクセス（IPアドレス、DNS名）を提供し、負荷分散も行います。\n\n【Serviceが必要な理由】\n・Podは動的に生成/削除される\n・PodのIPアドレスは変動する\n・Serviceは固定のエンドポイントを提供\n\n【Serviceの種類】\n・ClusterIP：クラスタ内部からのみアクセス\n・NodePort：ノードのポートで公開\n・LoadBalancer：外部LBで公開\n\n【他の選択肢】\n・コンテナイメージ保存 → Container Registry\n・ノード管理 → kubelet/Master\n・ログ収集 → Fluentd等のログ収集ツール\n\n【覚え方】\nService=Podへの「窓口」。Podが変わっても同じアドレスでアクセス可能",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 148,
      "category": "クラウド",
      "question": "AWSのリージョンとアベイラビリティゾーン（AZ）の関係として正しいものはどれか？",
      "choices": [
        "1つのAZに複数のリージョンがある",
        "1つのリージョンに複数のAZがある",
        "リージョンとAZは同じ意味",
        "AZはリージョンを跨いで配置される"
      ],
      "answer": 1,
      "explanation": "1つのリージョン（地理的領域）には複数のAZ（独立したデータセンター群）が存在し、高可用性を実現できます。\n\n【AWS構成の階層】\nリージョン > アベイラビリティゾーン(AZ) > データセンター\n・リージョン：地理的に離れた地域（東京、大阪等）\n・AZ：リージョン内の独立したデータセンター群（通常2-3以上）\n・各AZは独立した電源・冷却・ネットワークを持つ\n\n【マルチAZ構成のメリット】\n・1つのAZ障害でもサービス継続\n・データのレプリケーションで耐障害性向上\n・低遅延の同期が可能（同一リージョン内）\n\n【覚え方】\nリージョン=「地域」、AZ=「建物群」。東京リージョンに複数の独立した建物がある",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 149,
      "category": "クラウド",
      "question": "GitOpsの特徴として正しいものはどれか？",
      "choices": [
        "手動でインフラを管理する",
        "Gitリポジトリを単一の情報源として使用",
        "コードとインフラを分離する",
        "継続的インテグレーションのみを行う"
      ],
      "answer": 1,
      "explanation": "GitOpsはGitリポジトリを単一の情報源とし、宣言的にインフラとアプリケーションを管理する手法です。\n\n【GitOpsの原則】\n1. 宣言的記述：あるべき状態をコードで定義\n2. Git=Single Source of Truth：Gitが唯一の真実\n3. 自動適用：変更は自動的にシステムに反映\n4. 継続的な調整：差分検知と自動修復\n\n【GitOpsのワークフロー】\n1. 開発者がGitに変更をプッシュ\n2. CIでテスト・ビルド\n3. 設定リポジトリを更新\n4. GitOpsツールが変更を検知・自動適用\n\n【代表的なツール】\n・Argo CD、Flux\n\n【覚え方】\nGitOps=「Gitがすべての源」。Gitの内容と本番環境を常に同期させる",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 150,
      "category": "クラウド",
      "question": "カナリアリリースの特徴として正しいものはどれか？",
      "choices": [
        "全ユーザーに同時に新バージョンを公開",
        "一部のユーザーに新バージョンを公開し様子を見る",
        "2つの環境を瞬時に切り替える",
        "テスト環境でのみ検証する"
      ],
      "answer": 1,
      "explanation": "カナリアリリースは一部のユーザー（例：5%）に新バージョンを公開し、問題がないことを確認してから段階的に拡大する手法です。\n\n【カナリアリリースの流れ】\n1. 新バージョンを少数（5-10%）にリリース\n2. エラー率、レスポンス時間を監視\n3. 問題なければ徐々に拡大（20%→50%→100%）\n4. 問題あれば即座にロールバック\n\n【他の選択肢】\n・全ユーザーに同時公開 → ビッグバンリリース\n・2環境を瞬時切り替え → Blue-Greenデプロイ\n・テスト環境のみ → ステージング検証\n\n【名前の由来】\n炭鉱のカナリア：有毒ガスを早期検知する「炭鉱のカナリア」が由来。一部ユーザーで問題を早期発見\n\n【覚え方】\nカナリア=「先遣隊」。少数で試して問題なければ全員に展開",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 151,
      "category": "クラウド",
      "question": "クラウドの従量課金モデルのメリットはどれか？",
      "choices": [
        "初期投資が大きい",
        "使った分だけ支払う",
        "固定費が予測しやすい",
        "長期契約が必須"
      ],
      "answer": 1,
      "explanation": "従量課金は使用した分だけ支払うため、初期投資を抑え、需要に応じてコストを最適化できます。\n\n【クラウドの課金モデル】\n| 種類 | 特徴 |\n|------|------|\n| オンデマンド | 使った分だけ支払い |\n| リザーブド | 1-3年予約で大幅割引 |\n| スポット | 余剰リソースを格安利用 |\n| Savings Plans | 使用量コミットで割引 |\n\n【従量課金のメリット】\n・初期投資不要（CAPEX→OPEX）\n・スモールスタートが可能\n・需要変動に柔軟に対応\n\n【他の選択肢】\n・初期投資大 → オンプレミスの特徴\n・固定費予測しやすい → 月額固定型\n・長期契約必須 → リザーブドインスタンス\n\n【覚え方】\n従量=「使った量に従う」。水道代・電気代のような課金方式",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 152,
      "category": "クラウド",
      "question": "AWS RDSの特徴として正しいものはどれか？",
      "choices": [
        "NoSQLデータベースサービス",
        "マネージドリレーショナルデータベースサービス",
        "オブジェクトストレージサービス",
        "サーバーレスコンピューティングサービス"
      ],
      "answer": 1,
      "explanation": "RDS（Relational Database Service）はMySQL、PostgreSQL、Oracle等のRDBMSをマネージドサービスとして提供します。\n\n【RDSの特徴】\n・自動バックアップ、パッチ適用\n・マルチAZで高可用性\n・リードレプリカでスケーリング\n・暗号化対応\n\n【対応データベースエンジン】\nMySQL、PostgreSQL、MariaDB、Oracle、SQL Server、Aurora\n\n【他の選択肢】\n・NoSQL → DynamoDB\n・オブジェクトストレージ → S3\n・サーバーレス → Lambda\n\n【AWSのDB関連サービス】\n・RDS：マネージドRDB\n・Aurora：AWSオリジナル高性能RDB\n・DynamoDB：NoSQL\n・ElastiCache：インメモリキャッシュ\n・Redshift：データウェアハウス\n\n【覚え方】\nRDS=「お任せRDB」。面倒な運用はAWSがやってくれる",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 153,
      "category": "クラウド",
      "question": "イミュータブルインフラストラクチャの特徴として正しいものはどれか？",
      "choices": [
        "稼働中のサーバーを変更する",
        "サーバーを変更せず新しいものに置き換える",
        "手動で設定変更を行う",
        "設定のドリフトを許容する"
      ],
      "answer": 1,
      "explanation": "イミュータブルインフラストラクチャは既存サーバーを変更せず、新しいイメージから構築した環境に置き換える手法です。\n\n【ミュータブル vs イミュータブル】\n| 項目 | ミュータブル | イミュータブル |\n|------|------------|----------------|\n| 変更方法 | 既存サーバーを更新 | 新サーバーに置換 |\n| 設定ドリフト | 発生しやすい | 発生しない |\n| 再現性 | 低い | 高い |\n| ロールバック | 困難 | 容易 |\n\n【イミュータブルの利点】\n・環境の一貫性が保たれる\n・テスト済み環境をそのままデプロイ\n・問題時は前のイメージに戻すだけ\n\n【覚え方】\nイミュータブル=immutable=「変えられない」。一度作ったら変更せず、新しく作り直す",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 154,
      "category": "クラウド",
      "question": "サービスメッシュの役割として正しいものはどれか？",
      "choices": [
        "コンテナイメージの管理",
        "マイクロサービス間通信の制御",
        "データベースの管理",
        "ストレージの提供"
      ],
      "answer": 1,
      "explanation": "サービスメッシュ（Istio等）はマイクロサービス間の通信を制御し、トラフィック管理、認証、可観測性を提供します。\n\n【サービスメッシュの機能】\n・トラフィック管理：ルーティング、負荷分散\n・セキュリティ：mTLS（相互TLS）認証\n・可観測性：トレーシング、メトリクス収集\n・回復力：リトライ、サーキットブレーカー\n\n【サイドカーパターン】\n・各サービスにプロキシ（Envoy等）を配置\n・アプリケーションコードを変更せずに機能追加\n\n【代表的なツール】\n・Istio、Linkerd、Consul Connect\n\n【他の選択肢】\n・コンテナイメージ管理 → Container Registry\n・データベース管理 → RDS等\n・ストレージ提供 → S3等\n\n【覚え方】\nメッシュ=「網目」。サービス間通信の網目を管理する",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 155,
      "category": "クラウド",
      "question": "FinOpsの目的として正しいものはどれか？",
      "choices": [
        "クラウドセキュリティの強化",
        "クラウドコストの最適化と管理",
        "クラウド移行の計画",
        "クラウドアーキテクチャの設計"
      ],
      "answer": 1,
      "explanation": "FinOpsはクラウドの財務管理実践で、エンジニアリング、財務、ビジネスが協力してクラウドコストを最適化します。\n\n【FinOpsの3つのフェーズ】\n1. Inform（情報収集）：コスト可視化、レポート\n2. Optimize（最適化）：無駄の削減、リソース適正化\n3. Operate（運用）：継続的なコスト管理\n\n【FinOpsの主な活動】\n・コストの可視化とタグ付け\n・未使用リソースの特定・削除\n・リザーブドインスタンスの活用\n・適切なインスタンスサイズの選定\n\n【他の選択肢】\n・セキュリティ強化 → SecOps\n・クラウド移行計画 → マイグレーション\n・アーキテクチャ設計 → Well-Architected\n\n【覚え方】\nFinOps=Finance+Ops。「お金（Finance）」と「運用（Ops）」を組み合わせた造語",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 156,
      "category": "セキュリティ",
      "question": "WAFの主な役割として正しいものはどれか？",
      "choices": [
        "ネットワーク層の攻撃を防ぐ",
        "Webアプリケーション層の攻撃を防ぐ",
        "ウイルスを検出する",
        "データを暗号化する"
      ],
      "answer": 1,
      "explanation": "WAF（Web Application Firewall）はSQLインジェクションやXSSなどWebアプリケーション層の攻撃を検知・防御します。\n\n【ファイアウォールの種類と役割】\n| 種類 | 層 | 防御対象 |\n|------|----|---------|\n| パケットフィルタ | L3-4 | IPアドレス、ポート |\n| ステートフルFW | L3-4 | 接続状態を追跡 |\n| WAF | L7 | SQLi、XSS等 |\n| NGFW | L3-7 | 全層を統合防御 |\n\n【WAFの検知方式】\n・シグネチャベース：既知の攻撃パターンと照合\n・振る舞いベース：異常な挙動を検知\n\n【他の選択肢】\n・ネットワーク層攻撃 → 通常のファイアウォール\n・ウイルス検出 → アンチウイルスソフト\n・データ暗号化 → TLS/暗号化ツール\n\n【覚え方】\nWAF=Web Application Firewall。「Webアプリ専用」のファイアウォール",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 157,
      "category": "セキュリティ",
      "question": "HTTPS通信で使用される暗号化方式の組み合わせとして正しいものはどれか？",
      "choices": [
        "共通鍵暗号のみ",
        "公開鍵暗号のみ",
        "公開鍵暗号と共通鍵暗号のハイブリッド",
        "ハッシュ関数のみ"
      ],
      "answer": 2,
      "explanation": "HTTPSは鍵交換に公開鍵暗号を使い、その後のデータ通信には高速な共通鍵暗号を使うハイブリッド方式です。\n\n【TLS/SSLハンドシェイクの流れ】\n1. クライアントがサーバーに接続要求\n2. サーバーが証明書（公開鍵含む）を送信\n3. クライアントが共通鍵を生成し、公開鍵で暗号化して送信\n4. 以降は共通鍵で暗号化通信\n\n【ハイブリッド方式の理由】\n・公開鍵暗号：安全に鍵交換できるが遅い\n・共通鍵暗号：高速だが鍵の受け渡しが課題\n→両者の利点を組み合わせる\n\n【他の選択肢】\n・共通鍵のみ → 鍵配送問題が解決できない\n・公開鍵のみ → 処理が遅すぎる\n・ハッシュのみ → 暗号化ではなく完全性検証\n\n【覚え方】\nHTTPS=「公開鍵で安全に渡して、共通鍵で高速通信」のハイブリッド",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 158,
      "category": "セキュリティ",
      "question": "CSRFの説明として正しいものはどれか？",
      "choices": [
        "悪意のあるスクリプトを埋め込む攻撃",
        "ユーザーの意図しないリクエストを送信させる攻撃",
        "SQLクエリを改ざんする攻撃",
        "通信を傍受する攻撃"
      ],
      "answer": 1,
      "explanation": "CSRF（Cross-Site Request Forgery）は、ユーザーが意図しないリクエストを攻撃者が用意したページから送信させる攻撃です。\n\n【CSRFの仕組み】\n1. ユーザーが正規サイトにログイン中\n2. 攻撃者の罠サイトにアクセス\n3. 罠サイトから正規サイトへリクエスト送信\n4. ログイン状態のため処理が実行される\n\n【CSRF対策】\n・CSRFトークン（ワンタイムトークン）\n・Refererヘッダーのチェック\n・SameSite Cookie属性\n・重要操作時の再認証\n\n【他の選択肢】\n・悪意のスクリプト埋め込み → XSS\n・SQLクエリ改ざん → SQLインジェクション\n・通信傍受 → 中間者攻撃（MITM）\n\n【覚え方】\nCSRF=「なりすましリクエスト」。ユーザーの「意図しない操作」を実行させる",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 159,
      "category": "セキュリティ",
      "question": "SOCの役割として正しいものはどれか？",
      "choices": [
        "ソフトウェアの開発",
        "セキュリティ監視と incident対応",
        "ネットワーク機器の保守",
        "データベースの管理"
      ],
      "answer": 1,
      "explanation": "SOC（Security Operation Center）はセキュリティイベントの監視、分析、インシデント対応を24時間体制で行う組織です。\n\n【SOCの主な業務】\n・24時間365日のセキュリティ監視\n・アラートのトリアージ（優先度付け）\n・インシデントの初動対応\n・脅威インテリジェンスの収集・分析\n・セキュリティレポートの作成\n\n【関連組織との違い】\n| 組織 | 役割 |\n|------|------|\n| SOC | 監視・検知・初動対応 |\n| CSIRT | インシデント対応（調査・復旧） |\n| NOC | ネットワーク運用監視 |\n\n【他の選択肢】\n・ソフトウェア開発 → 開発チーム\n・NW機器保守 → NOC（Network Operation Center）\n・DB管理 → DBA（Database Administrator）\n\n【覚え方】\nSOC=Security Operation Center。セキュリティの「見張り番」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 160,
      "category": "セキュリティ",
      "question": "ペネトレーションテストの目的として正しいものはどれか？",
      "choices": [
        "システムの性能を測定する",
        "攻撃者視点でセキュリティの脆弱性を検証する",
        "コードの品質を評価する",
        "ユーザビリティをテストする"
      ],
      "answer": 1,
      "explanation": "ペネトレーションテストは攻撃者の視点で実際に侵入を試み、セキュリティ上の脆弱性を発見・検証するテストです。\n\n【ペネトレーションテストの種類】\n・ブラックボックス：システム情報なしで実施\n・ホワイトボックス：システム情報ありで実施\n・グレーボックス：一部情報ありで実施\n\n【テストの流れ】\n1. 計画・スコープ定義\n2. 情報収集（偵察）\n3. 脆弱性スキャン\n4. 侵入試行（エクスプロイト）\n5. 権限昇格・横展開\n6. レポート作成\n\n【脆弱性診断との違い】\n・脆弱性診断：脆弱性の「発見」が目的\n・ペネトレーションテスト：「侵入可能か」の実証が目的\n\n【覚え方】\nペネトレーション=Penetration（侵入）。「本当に侵入できるか」を試す実践的テスト",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 161,
      "category": "セキュリティ",
      "question": "最小権限の原則の説明として正しいものはどれか？",
      "choices": [
        "全ユーザーに同じ権限を付与する",
        "必要最小限の権限のみを付与する",
        "管理者権限を全員に付与する",
        "権限を時間で制限する"
      ],
      "answer": 1,
      "explanation": "最小権限の原則は、ユーザーやプロセスに業務に必要な最小限の権限のみを付与することでセキュリティリスクを低減します。\n\n【最小権限の原則の適用例】\n・一般ユーザーには管理者権限を与えない\n・アプリにはDBの必要なテーブルのみアクセス許可\n・サービスアカウントは必要最小限の権限で実行\n\n【関連するセキュリティ原則】\n・Need to Know：業務に必要な情報のみアクセス\n・職務分離：権限を分散して不正を防止\n・ゼロトラスト：常に検証、最小権限で実行\n\n【他の選択肢】\n・全ユーザー同権限 → 権限過剰でリスク増\n・全員管理者権限 → 最悪のセキュリティ状態\n・時間制限 → 時間ベースアクセス制御（別概念）\n\n【覚え方】\n最小権限=「必要最低限しか渡さない」。万が一侵害されても被害を最小化",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 162,
      "category": "セキュリティ",
      "question": "SSO（シングルサインオン）の利点として正しいものはどれか？",
      "choices": [
        "各システムで異なるパスワードが必要",
        "一度の認証で複数システムにアクセス可能",
        "二要素認証が不要になる",
        "パスワードの複雑さを下げられる"
      ],
      "answer": 1,
      "explanation": "SSOは一度の認証で複数のシステムやアプリケーションにアクセスできるため、ユーザーの利便性とセキュリティが向上します。\n\n【SSOのメリット】\n・パスワード管理の負担軽減\n・パスワード使い回しリスクの低減\n・ログイン操作の効率化\n・統一的なアクセス管理が可能\n\n【SSOの実装方式】\n・SAML（Security Assertion Markup Language）\n・OAuth/OpenID Connect\n・Kerberos\n\n【代表的なSSO製品】\n・Okta、Azure AD、Google Workspace、AWS IAM Identity Center\n\n【他の選択肢】\n・各システムで異なるPW → SSO導入前の状態\n・二要素認証不要 → SSOと二要素認証は併用すべき\n・PW複雑さ低減 → セキュリティ低下のため不適切\n\n【覚え方】\nSSO=Single Sign-On。「一度のサインオンで全部OK」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 163,
      "category": "セキュリティ",
      "question": "セキュリティにおける「多層防御」の考え方として正しいものはどれか？",
      "choices": [
        "最も強力な1つの対策に依存する",
        "複数の防御層を設けてリスクを低減する",
        "攻撃を受けてから対策する",
        "コストを最小限に抑える"
      ],
      "answer": 1,
      "explanation": "多層防御は複数のセキュリティ対策を重ねて配置し、1つの層が突破されても他の層で防御できるようにする考え方です。\n\n【多層防御の例】\n| 層 | 対策例 |\n|----|--------|\n| 物理層 | 入退室管理、監視カメラ |\n| ネットワーク層 | ファイアウォール、IDS/IPS |\n| ホスト層 | アンチウイルス、OS更新 |\n| アプリ層 | WAF、入力検証 |\n| データ層 | 暗号化、アクセス制御 |\n\n【多層防御の利点】\n・単一障害点（SPOF）の排除\n・攻撃者の侵入コスト増大\n・異なる脅威への対応力向上\n\n【他の選択肢】\n・1つの対策に依存 → 単一障害点となりリスク高\n・攻撃後対策 → 予防的対策が重要\n・コスト最小化 → セキュリティと相反\n\n【覚え方】\n多層防御=「玉ねぎの皮」。何層もの防御で中心を守る",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 164,
      "category": "セキュリティ",
      "question": "IDSとIPSの違いとして正しいものはどれか？",
      "choices": [
        "IDSは攻撃を遮断し、IPSは検知のみ",
        "IDSは検知のみ、IPSは攻撃を遮断できる",
        "両者に違いはない",
        "IDSはホスト型、IPSはネットワーク型"
      ],
      "answer": 1,
      "explanation": "IDS（侵入検知システム）は不正アクセスを検知・通知し、IPS（侵入防止システム）は検知に加えて遮断も行えます。\n\n【IDS/IPSの比較】\n| 項目 | IDS | IPS |\n|------|-----|-----|\n| 機能 | 検知・通知 | 検知＋遮断 |\n| 配置 | ミラーポート等 | インライン |\n| 遅延 | 影響なし | わずかにあり |\n| 誤検知リスク | 低（通知のみ） | 高（誤遮断の恐れ） |\n\n【設置形態】\n・NIDS/NIPS：ネットワーク型（通信を監視）\n・HIDS/HIPS：ホスト型（サーバー上で監視）\n\n【検知方式】\n・シグネチャベース：既知の攻撃パターンと照合\n・アノマリーベース：通常と異なる挙動を検知\n\n【覚え方】\nIDS=Intrusion Detection System（検知）、IPS=Intrusion Prevention System（防止）。Pは「Prevent（防ぐ）」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 165,
      "category": "セキュリティ",
      "question": "ソーシャルエンジニアリングの説明として正しいものはどれか？",
      "choices": [
        "技術的な脆弱性を悪用する攻撃",
        "人間の心理的弱点を悪用する攻撃",
        "マルウェアを使用する攻撃",
        "ネットワークを傍受する攻撃"
      ],
      "answer": 1,
      "explanation": "ソーシャルエンジニアリングは技術ではなく、人間の心理的な弱点（信頼、恐怖、好奇心等）を悪用して情報を盗む攻撃手法です。\n\n【ソーシャルエンジニアリングの手法】\n・フィッシング：偽メール/サイトで騙す\n・プリテキスティング：身分詐称（IT管理者を装う等）\n・ベイティング：USBメモリ等で誘い込む\n・ショルダーハッキング：後ろから覗き見る\n・テールゲーティング：正規社員に紛れて侵入\n\n【悪用される心理】\n・権威への服従、親切心、好奇心、恐怖、時間的プレッシャー\n\n【対策】\n・セキュリティ意識向上研修\n・手順の明確化（電話での情報開示禁止等）\n・不審な連絡の報告体制\n\n【覚え方】\nソーシャル=「社会的/人間的」。技術ではなく「人間」を狙う攻撃",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 166,
      "category": "セキュリティ",
      "question": "AESの説明として正しいものはどれか？",
      "choices": [
        "非対称暗号アルゴリズム",
        "共通鍵暗号アルゴリズム",
        "ハッシュ関数",
        "デジタル署名アルゴリズム"
      ],
      "answer": 1,
      "explanation": "AES（Advanced Encryption Standard）は現在広く使用されている共通鍵暗号アルゴリズムで、128/192/256ビットの鍵長をサポートします。\n\n【AESの特徴】\n・ブロック暗号（128ビットブロック）\n・鍵長：128/192/256ビット\n・DESの後継として2001年に標準化\n・高速で安全性が高い\n\n【暗号アルゴリズムの分類】\n| 分類 | 特徴 | 例 |\n|------|------|----|\n| 共通鍵暗号 | 同じ鍵で暗号化/復号 | AES, DES |\n| 公開鍵暗号 | 異なる鍵のペア | RSA, ECDSA |\n| ハッシュ関数 | 一方向変換 | SHA-256 |\n\n【他の選択肢】\n・非対称暗号 → RSA、楕円曲線暗号\n・ハッシュ関数 → SHA-256、MD5\n・デジタル署名 → RSA署名、ECDSA\n\n【覚え方】\nAES=「現代の標準暗号」。A=Advanced（進んだ）、E=Encryption（暗号化）、S=Standard（標準）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 167,
      "category": "セキュリティ",
      "question": "セキュリティインシデント対応の最初のステップとして適切なものはどれか？",
      "choices": [
        "復旧作業を開始する",
        "インシデントの検知と識別",
        "再発防止策を策定する",
        "経営層に報告する"
      ],
      "answer": 1,
      "explanation": "インシデント対応は検知・識別から始まり、封じ込め、根絶、復旧、事後対応（教訓化）の順で進めます。\n\n【インシデント対応の6段階（NIST準拠）】\n1. 準備：体制整備、ツール準備\n2. 検知・識別：異常の発見と影響範囲の特定\n3. 封じ込め：被害拡大の防止\n4. 根絶：原因の除去\n5. 復旧：システムの正常化\n6. 事後対応：振り返り、再発防止策\n\n【他の選択肢】\n・復旧作業開始 → 原因特定前の復旧は再発の恐れ\n・再発防止策策定 → 最後のステップ\n・経営層報告 → 識別後、影響に応じて報告\n\n【覚え方】\n「見つける→止める→消す→直す→学ぶ」の順序。まずは検知・識別から",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 168,
      "category": "セキュリティ",
      "question": "フィッシング攻撃の特徴として正しいものはどれか？",
      "choices": [
        "マルウェアを直接インストールする",
        "偽のWebサイトやメールで個人情報を詐取する",
        "ネットワークを物理的に盗聴する",
        "パスワードを総当たりで試す"
      ],
      "answer": 1,
      "explanation": "フィッシングは正規のサービスを装った偽のメールやWebサイトでユーザーを騙し、認証情報などを盗む攻撃です。\n\n【フィッシングの種類】\n・メールフィッシング：偽メールでリンクに誘導\n・スピアフィッシング：特定個人を狙った標的型\n・ホエーリング：経営層を狙った攻撃\n・スミッシング：SMSを使用\n・ビッシング：電話を使用\n\n【フィッシングの特徴】\n・緊急性を煽る文面（「今すぐ対応を」）\n・類似ドメイン（1が小文字のLに見える等）\n・正規サイトそっくりのデザイン\n\n【他の選択肢】\n・マルウェア直接インストール → ドライブバイダウンロード\n・物理的盗聴 → 盗聴器/傍受\n・総当たり → ブルートフォース攻撃\n\n【覚え方】\nフィッシング=Phishing（Fishing=釣りの造語）。「エサで釣る」攻撃",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 169,
      "category": "セキュリティ",
      "question": "SIEM（Security Information and Event Management）の役割として正しいものはどれか？",
      "choices": [
        "ファイアウォールの管理",
        "セキュリティログの収集・分析・相関付け",
        "ウイルスの駆除",
        "暗号化の実行"
      ],
      "answer": 1,
      "explanation": "SIEMは様々なシステムからセキュリティログを収集し、分析・相関付けを行い、脅威の検出とインシデント対応を支援します。\n\n【SIEMの主な機能】\n・ログ収集：各種デバイス・アプリからログを集約\n・正規化：異なるフォーマットを統一\n・相関分析：複数イベントを関連付けて脅威を検出\n・アラート：異常検知時に通知\n・レポート：コンプライアンス対応レポート生成\n\n【SIEMの進化】\n・SIEM：ログ収集・分析\n・SOAR：自動対応（Security Orchestration, Automation and Response）\n・XDR：エンドポイント/ネットワーク/クラウドを統合監視\n\n【代表的な製品】\n・Splunk、Microsoft Sentinel、IBM QRadar、Elastic SIEM\n\n【覚え方】\nSIEM=Security Information and Event Management。「ログの総合分析センター」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 170,
      "category": "セキュリティ",
      "question": "バッファオーバーフロー攻撃の説明として正しいものはどれか？",
      "choices": [
        "大量のリクエストでサーバーを過負荷にする",
        "メモリ領域を超えるデータを書き込み不正な動作を引き起こす",
        "偽のDNS応答を返す",
        "セッションIDを盗む"
      ],
      "answer": 1,
      "explanation": "バッファオーバーフローはプログラムが想定したメモリ領域を超えるデータを書き込み、任意のコード実行などを引き起こす攻撃です。\n\n【バッファオーバーフローの種類】\n・スタックオーバーフロー：戻りアドレスを上書き\n・ヒープオーバーフロー：動的メモリ領域を上書き\n\n【攻撃の仕組み】\n1. バッファサイズを超えるデータを入力\n2. 隣接するメモリ領域（戻りアドレス等）を上書き\n3. プログラムの制御フローを乗っ取る\n4. 任意のコードを実行\n\n【対策】\n・安全な関数の使用（strcpy→strncpy等）\n・ASLR（アドレス空間のランダム化）\n・DEP/NX（実行禁止領域の設定）\n・カナリア値（スタック保護）\n\n【覚え方】\nバッファ=「入れ物」。入れ物からあふれた（Overflow）データが悪さをする",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 171,
      "category": "DX技術",
      "question": "機械学習における「教師なし学習」の例として正しいものはどれか？",
      "choices": [
        "スパムメール分類",
        "クラスタリング",
        "画像認識",
        "音声認識"
      ],
      "answer": 1,
      "explanation": "クラスタリングは正解ラベルなしでデータをグループ化する教師なし学習の代表例です。スパム分類や画像認識は教師あり学習です。\n\n【教師なし学習の手法】\n・クラスタリング：データのグループ化（K-means等）\n・次元削減：データ圧縮（PCA等）\n・異常検知：外れ値の発見\n・アソシエーションルール：関連パターン発見\n\n【教師あり vs 教師なし】\n| 項目 | 教師あり | 教師なし |\n|------|----------|----------|\n| ラベル | 必要 | 不要 |\n| 目的 | 予測・分類 | パターン発見 |\n| 例 | スパム判定 | 顧客セグメント |\n\n【他の選択肢】\n・スパム分類、画像認識、音声認識 → いずれも教師あり学習\n\n【覚え方】\n教師なし=「正解なしで自分でパターンを見つける」。クラスタ=「集まり」を発見",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 172,
      "category": "DX技術",
      "question": "自然言語処理（NLP）のタスクとして適切でないものはどれか？",
      "choices": [
        "感情分析",
        "機械翻訳",
        "画像分類",
        "固有表現抽出"
      ],
      "answer": 2,
      "explanation": "画像分類はコンピュータビジョンのタスクです。NLPのタスクには感情分析、機械翻訳、固有表現抽出などがあります。\n\n【NLP（自然言語処理）の主なタスク】\n・感情分析：テキストの感情を判定\n・機械翻訳：言語間の翻訳\n・固有表現抽出（NER）：人名、地名等を抽出\n・質問応答：質問に回答\n・文書要約：長文を短くまとめる\n・テキスト生成：文章を自動生成\n\n【コンピュータビジョンのタスク】\n・画像分類、物体検出、セグメンテーション、顔認識\n\n【他の選択肢】\n・感情分析、機械翻訳、固有表現抽出 → すべてNLPタスク\n\n【覚え方】\nNLP=Natural Language Processing。「言葉」を扱うAI技術",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 173,
      "category": "DX技術",
      "question": "過学習（オーバーフィッティング）の説明として正しいものはどれか？",
      "choices": [
        "訓練データでも精度が低い状態",
        "訓練データに適合しすぎて汎化性能が低い状態",
        "学習に時間がかかりすぎる状態",
        "データ量が不足している状態"
      ],
      "answer": 1,
      "explanation": "過学習は訓練データに過度に適合し、未知のデータに対する汎化性能が低下する現象です。\n\n【過学習 vs 未学習】\n| 状態 | 訓練データ | テストデータ | 原因 |\n|------|-----------|-------------|------|\n| 過学習 | 高精度 | 低精度 | モデルが複雑すぎ |\n| 未学習 | 低精度 | 低精度 | モデルが単純すぎ |\n\n【過学習の対策】\n・正則化（L1/L2）\n・ドロップアウト\n・データ拡張\n・早期打ち切り（Early Stopping）\n・クロスバリデーション\n\n【他の選択肢】\n・訓練でも精度低 → 未学習（アンダーフィッティング）\n・学習時間がかかる → 計算資源の問題\n・データ量不足 → 過学習の一因ではあるが定義ではない\n\n【覚え方】\n過学習=「答えを丸暗記」。訓練問題は解けるが応用が利かない状態",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 174,
      "category": "DX技術",
      "question": "LiDARの用途として正しいものはどれか？",
      "choices": [
        "音声認識",
        "3D距離測定・地形計測",
        "無線通信",
        "データ暗号化"
      ],
      "answer": 1,
      "explanation": "LiDAR（Light Detection and Ranging）はレーザー光で3D距離を測定する技術で、自動運転や地形計測に使用されます。\n\n【LiDARの仕組み】\n1. レーザー光を照射\n2. 対象物からの反射光を検出\n3. 往復時間から距離を計算\n4. 点群データ（3D）を生成\n\n【LiDARの活用例】\n・自動運転車：周囲の障害物検知\n・地形計測：測量、災害対策\n・建築：3Dモデリング\n・考古学：遺跡発見\n\n【類似技術との比較】\n| 技術 | 使用 | 特徴 |\n|------|------|------|\n| LiDAR | レーザー光 | 高精度3D |\n| Radar | 電波 | 悪天候に強い |\n| カメラ | 可視光 | 色情報あり |\n\n【覚え方】\nLiDAR=Light Detection。「光で測る」距離計測技術",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 175,
      "category": "DX技術",
      "question": "5Gの特徴として正しいものはどれか？",
      "choices": [
        "4Gと同等の通信速度",
        "高速大容量、低遅延、多数同時接続",
        "音声通話専用の規格",
        "Wi-Fiの後継技術"
      ],
      "answer": 1,
      "explanation": "5Gは高速大容量（eMBB）、超低遅延（URLLC）、多数同時接続（mMTC）の3つの特徴を持つモバイル通信規格です。\n\n【5Gの3大特徴】\n・eMBB：高速大容量（最大20Gbps）\n・URLLC：超低遅延（1ms以下）\n・mMTC：多数同時接続（1km²に100万台）\n\n【世代別比較】\n| 世代 | 速度 | 遅延 | 主な用途 |\n|------|------|------|----------|\n| 3G | 数Mbps | 100ms | 音声・メール |\n| 4G | 100Mbps | 50ms | 動画・アプリ |\n| 5G | 10Gbps | 1ms | IoT・自動運転 |\n\n【5Gの活用例】\n・自動運転、遠隔医療、スマート工場、VR/ARストリーミング\n\n【覚え方】\n5Gの3つ=「速い・遅延ない・たくさんつながる」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 176,
      "category": "DX技術",
      "question": "生成AI（Generative AI）の例として正しいものはどれか？",
      "choices": [
        "スパムフィルター",
        "レコメンドシステム",
        "ChatGPT",
        "異常検知システム"
      ],
      "answer": 2,
      "explanation": "ChatGPTはテキストを生成する生成AIの代表例です。スパムフィルターや異常検知は分類・検知タスクです。\n\n【生成AIの種類】\n| 種類 | 生成対象 | 例 |\n|------|----------|----|\n| テキスト生成 | 文章 | ChatGPT、Claude |\n| 画像生成 | 画像 | DALL-E、Midjourney |\n| 音声生成 | 音声 | WaveNet |\n| 動画生成 | 動画 | Sora |\n| コード生成 | プログラム | GitHub Copilot |\n\n【識別AI vs 生成AI】\n・識別AI：分類、検知（スパム判定等）\n・生成AI：新しいコンテンツを創造\n\n【他の選択肢】\n・スパムフィルター → 分類タスク（識別AI）\n・レコメンド → 推薦タスク\n・異常検知 → 検知タスク（識別AI）\n\n【覚え方】\n生成AI=「新しいものを作る」AI。識別AI=「見分ける」AI",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 177,
      "category": "DX技術",
      "question": "スマートコントラクトの説明として正しいものはどれか？",
      "choices": [
        "電子署名された契約書",
        "ブロックチェーン上で自動実行されるプログラム",
        "AIによる契約書作成",
        "紙の契約書のデジタル化"
      ],
      "answer": 1,
      "explanation": "スマートコントラクトはブロックチェーン上で条件に応じて自動実行されるプログラムで、契約の自動化に使用されます。\n\n【スマートコントラクトの特徴】\n・条件を満たすと自動で実行\n・改ざん不可能\n・仲介者不要\n・透明性が高い\n\n【活用例】\n・NFT取引：所有権の自動移転\n・DeFi：自動化された金融サービス\n・サプライチェーン：条件付き支払い\n・保険：条件成立時の自動支払い\n\n【主要プラットフォーム】\n・Ethereum（Solidity言語）\n・Solana、Polygon等\n\n【他の選択肢】\n・電子署名契約書 → 電子契約サービス\n・AI契約書作成 → AIライティングツール\n・紙のデジタル化 → スキャン・電子化\n\n【覚え方】\nスマートコントラクト=「賢い契約」。条件を満たせば自動で契約履行",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 178,
      "category": "DX技術",
      "question": "AR（拡張現実）とVR（仮想現実）の違いとして正しいものはどれか？",
      "choices": [
        "ARは完全な仮想空間、VRは現実を拡張",
        "ARは現実にデジタル情報を重ねる、VRは完全な仮想空間",
        "両者に違いはない",
        "ARはゲーム専用、VRはビジネス専用"
      ],
      "answer": 1,
      "explanation": "ARは現実世界にデジタル情報を重ねて表示し、VRは完全な仮想空間にユーザーを没入させる技術です。\n\n【xRの種類】\n| 種類 | 特徴 | 例 |\n|------|------|----|\n| VR | 完全仮想空間 | ゲーム、訓練 |\n| AR | 現実＋デジタル | ポケモンGO |\n| MR | 現実と仮想の融合 | HoloLens |\n| XR | 上記の総称 | - |\n\n【活用例】\n・VR：ゲーム、医療訓練、不動産内覧\n・AR：ナビゲーション、製造業支援、教育\n・MR：設計レビュー、遠隔コラボレーション\n\n【必要デバイス】\n・VR：ヘッドマウントディスプレイ\n・AR：スマホ、ARグラス\n\n【覚え方】\nVR=Virtual（仮想）、AR=Augmented（拡張）、MR=Mixed（混合）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 179,
      "category": "DX技術",
      "question": "MLOpsの目的として正しいものはどれか？",
      "choices": [
        "機械学習モデルの学習のみを行う",
        "機械学習のライフサイクル全体を効率化する",
        "データの収集のみを自動化する",
        "モデルの精度を上げる"
      ],
      "answer": 1,
      "explanation": "MLOpsは機械学習モデルの開発、デプロイ、運用、モニタリングのライフサイクル全体を効率化・自動化する実践です。\n\n【MLOpsのライフサイクル】\n1. データ収集・前処理\n2. モデル開発・学習\n3. モデル評価・検証\n4. デプロイ（本番環境へ）\n5. モニタリング（性能監視）\n6. 再学習（必要に応じて）\n\n【DevOps vs MLOps】\n| 項目 | DevOps | MLOps |\n|------|--------|-------|\n| 対象 | アプリ | MLモデル |\n| 特有課題 | - | データドリフト、モデル劣化 |\n| バージョン管理 | コード | コード＋データ＋モデル |\n\n【代表的なツール】\n・MLflow、Kubeflow、Amazon SageMaker\n\n【覚え方】\nMLOps=ML（機械学習）+Ops（運用）。「MLのDevOps」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 180,
      "category": "DX技術",
      "question": "量子コンピュータの特徴として正しいものはどれか？",
      "choices": [
        "0と1のビットで計算する",
        "量子ビットで重ね合わせ状態を利用する",
        "従来のコンピュータより消費電力が少ない",
        "すべての問題で従来より高速"
      ],
      "answer": 1,
      "explanation": "量子コンピュータは量子ビット（qubit）の重ね合わせや量子もつれを利用し、特定の問題で並列計算の優位性を持ちます。\n\n【従来型 vs 量子コンピュータ】\n| 項目 | 従来型 | 量子 |\n|------|--------|------|\n| 単位 | ビット（0/1） | 量子ビット（重ね合わせ） |\n| 計算 | 逐次処理 | 並列的 |\n| 得意 | 汎用処理 | 特定の最適化問題 |\n\n【量子の特性】\n・重ね合わせ：0と1を同時に持てる\n・量子もつれ：離れた量子ビットが連動\n・干渉：確率振幅の操作\n\n【得意な問題】\n・暗号解読、最適化問題、量子シミュレーション\n\n【他の選択肢】\n・0と1のビット → 従来のコンピュータ\n・消費電力少 → 現状は冷却に大電力\n・全問題で高速 → 特定問題のみ優位\n\n【覚え方】\n量子=「重ね合わせ」で0と1を同時に。特定問題で圧倒的に速い",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 181,
      "category": "DX技術",
      "question": "RAG（Retrieval-Augmented Generation）の特徴として正しいものはどれか？",
      "choices": [
        "画像を生成する技術",
        "外部知識を検索して回答生成に活用する技術",
        "音声を認識する技術",
        "データを圧縮する技術"
      ],
      "answer": 1,
      "explanation": "RAGは大規模言語モデルが回答を生成する際に、外部の知識ベースから関連情報を検索して活用する手法です。\n\n【RAGの仕組み】\n1. 質問を受け取る\n2. 知識ベースから関連文書を検索（Retrieval）\n3. 検索結果を文脈としてLLMに渡す\n4. LLMが回答を生成（Augmented Generation）\n\n【RAGのメリット】\n・最新情報を扱える（学習データに依存しない）\n・ハルシネーション（誤情報生成）を軽減\n・出典を明示できる\n・ドメイン特化の知識を活用可能\n\n【類似技術との比較】\n・ファインチューニング：モデル自体を再学習\n・RAG：外部知識を参照して生成\n\n【覚え方】\nRAG=Retrieval（検索）+Augmented（強化）+Generation（生成）。「検索で強化した生成」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 182,
      "category": "DX技術",
      "question": "ディープフェイクの説明として正しいものはどれか？",
      "choices": [
        "深層学習を使用した画像圧縮技術",
        "AIで生成された偽の映像や音声",
        "セキュリティ対策技術",
        "データ暗号化技術"
      ],
      "answer": 1,
      "explanation": "ディープフェイクは深層学習を使って人物の顔や声を精巧に偽造する技術で、悪用のリスクが指摘されています。\n\n【ディープフェイクの技術】\n・GAN（敵対的生成ネットワーク）を使用\n・顔のすげ替え（Face Swap）\n・音声の合成（Voice Cloning）\n・リップシンク（口の動きを合成）\n\n【悪用のリスク】\n・偽ニュース、政治的プロパガンダ\n・詐欺、なりすまし\n・名誉毀損\n・プライバシー侵害\n\n【対策技術】\n・ディープフェイク検出AI\n・デジタル透かし\n・来歴証明（コンテンツ認証）\n\n【他の選択肢】\n・画像圧縮 → JPEG、WebP等\n・セキュリティ対策 → 暗号化、認証等\n・データ暗号化 → AES等\n\n【覚え方】\nDeep（深層学習）+Fake（偽物）。AIが作る「精巧な偽物」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 183,
      "category": "DX技術",
      "question": "AIにおける説明可能性（Explainability）の重要性として正しいものはどれか？",
      "choices": [
        "モデルの学習速度を向上させる",
        "AIの判断根拠を人間が理解できるようにする",
        "データ量を削減する",
        "計算コストを下げる"
      ],
      "answer": 1,
      "explanation": "説明可能なAI（XAI）はAIがなぜその判断をしたかを人間が理解できるようにし、信頼性や透明性を高めます。\n\n【XAIが必要な理由】\n・ブラックボックス問題：深層学習の判断根拠が不透明\n・法規制対応：説明責任（GDPR等）\n・信頼構築：ユーザーの納得感\n・デバッグ：モデルの問題発見\n\n【XAIの手法】\n・LIME：局所的な説明\n・SHAP：特徴量の貢献度を可視化\n・Attention可視化：注目箇所の表示\n・決定木：ルールベースで解釈可能\n\n【適用分野】\n・医療診断、金融審査、自動運転、法務\n\n【他の選択肢】\n・学習速度向上 → ハードウェア最適化、アルゴリズム改善\n・データ量削減 → 次元削減、サンプリング\n・計算コスト削減 → モデル軽量化\n\n【覚え方】\nXAI=eXplainable AI。「説明できる」AIで信頼性向上",
      "source": {
        "type": "original"
      },
      "difficulty": 3
    },
    {
      "id": 184,
      "category": "DX技術",
      "question": "Web3の特徴として正しいものはどれか？",
      "choices": [
        "中央集権的なプラットフォーム",
        "分散型・ブロックチェーンベースのインターネット",
        "静的なWebページ",
        "企業が管理するデータ"
      ],
      "answer": 1,
      "explanation": "Web3はブロックチェーン技術を基盤とした分散型のインターネットで、ユーザーがデータの所有権を持つことを目指します。\n\n【Webの進化】\n| 世代 | 特徴 | 主なサービス |\n|------|------|-------------|\n| Web1.0 | 閲覧中心 | 静的サイト |\n| Web2.0 | 参加・共有 | SNS、動画共有 |\n| Web3 | 分散・所有 | DeFi、NFT、DAO |\n\n【Web3の特徴】\n・分散型（中央管理者なし）\n・ユーザーがデータを所有\n・トークンエコノミー\n・自己主権型アイデンティティ\n\n【Web3の構成要素】\n・ブロックチェーン、スマートコントラクト\n・NFT、暗号資産\n・DAO（分散型自律組織）\n\n【他の選択肢】\n・中央集権プラットフォーム → Web2.0\n・静的ページ → Web1.0\n\n【覚え方】\nWeb3=「分散型Web」。GAFAからユーザーへ権力シフト",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 185,
      "category": "DX技術",
      "question": "APIエコノミーの説明として正しいものはどれか？",
      "choices": [
        "APIの開発コストを削減すること",
        "APIを通じてサービスを連携し価値を創出するビジネスモデル",
        "APIのセキュリティを強化すること",
        "APIの利用を制限すること"
      ],
      "answer": 1,
      "explanation": "APIエコノミーはAPIを通じて自社サービスを外部に公開し、エコシステムを形成して新たな価値を創出するビジネスモデルです。\n\n【APIエコノミーの要素】\n・APIプロバイダー：APIを公開する企業\n・APIコンシューマー：APIを利用する企業\n・APIマーケットプレイス：API流通の場\n\n【APIエコノミーのメリット】\n・新規ビジネス創出\n・開発コスト削減\n・エコシステム拡大\n・収益化（API課金）\n\n【成功事例】\n・Stripe（決済API）\n・Twilio（通信API）\n・Google Maps API\n・OpenAI API\n\n【他の選択肢】\n・開発コスト削減 → 一側面だが本質ではない\n・セキュリティ強化 → API管理の課題\n・利用制限 → オープン化が目的\n\n【覚え方】\nAPIエコノミー=「APIで稼ぐ経済圏」。サービスを部品化して連携・収益化",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 186,
      "category": "DX利活用",
      "question": "デザイン思考のプロセスに含まれないものはどれか？",
      "choices": [
        "共感（Empathize）",
        "定義（Define）",
        "実装（Implement）",
        "プロトタイプ（Prototype）"
      ],
      "answer": 2,
      "explanation": "デザイン思考は共感、定義、発想（Ideate）、プロトタイプ、テストの5段階で構成されます。「実装」は含まれません。\n\n【デザイン思考の5段階】\n1. 共感（Empathize）：ユーザーを理解する\n2. 定義（Define）：課題を明確化する\n3. 発想（Ideate）：アイデアを出す\n4. プロトタイプ（Prototype）：試作品を作る\n5. テスト（Test）：検証する\n\n【デザイン思考の特徴】\n・ユーザー中心のアプローチ\n・失敗を恐れず試行錯誤\n・チームでの協働\n・非線形プロセス（行き来OK）\n\n【適用場面】\n・新サービス開発、UX改善、組織変革\n\n【他の選択肢】\n・共感、定義、プロトタイプ → すべて5段階に含まれる\n・実装 → 開発フェーズでありデザイン思考のプロセスではない\n\n【覚え方】\n5段階=「共定発プテ」。共感→定義→発想→プロトタイプ→テスト",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 187,
      "category": "DX利活用",
      "question": "リーンスタートアップの核心的な考え方はどれか？",
      "choices": [
        "完璧な製品を作ってからリリース",
        "仮説検証を繰り返し素早く学習",
        "大規模な初期投資",
        "長期計画に基づく開発"
      ],
      "answer": 1,
      "explanation": "リーンスタートアップはMVP（実用最小限の製品）で仮説を検証し、Build-Measure-Learnのサイクルで素早く学習・改善します。\n\n【Build-Measure-Learnサイクル】\n1. Build（構築）：MVPを素早く作る\n2. Measure（計測）：市場の反応を測定\n3. Learn（学習）：データから学び方向転換\n\n【リーンスタートアップの概念】\n・MVP：最小限の機能で仮説検証\n・ピボット：方向転換（仮説が間違いなら変える）\n・バリデーテッドラーニング：検証済みの学習\n\n【従来型開発との違い】\n| 項目 | リーンスタートアップ | 従来型 |\n|------|----------------------|--------|\n| 計画 | 仮説ベース | 詳細計画 |\n| 開発 | 素早く小さく | 完璧を目指す |\n| 失敗 | 学習の機会 | 回避すべき |\n\n【他の選択肢】\n・完璧な製品を作る → MVPで最小限から始める\n・大規模投資 → 最小限の投資で検証\n・長期計画 → 短サイクルで柔軟に\n\n【覚え方】\nリーン=「無駄をなくす」。最小限で素早く学習する",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 188,
      "category": "DX利活用",
      "question": "OKR（Objectives and Key Results）の特徴として正しいものはどれか？",
      "choices": [
        "達成度100%を目標とする",
        "野心的な目標を設定し60-70%達成を目指す",
        "個人の評価に直接連動させる",
        "年1回のみ設定する"
      ],
      "answer": 1,
      "explanation": "OKRは野心的な目標（Objective）と測定可能な成果指標（Key Results）を設定し、60-70%の達成で成功とみなすフレームワークです。\n\n【OKRの構成】\n・Objective（目標）：定性的で野心的な目標\n・Key Results（成果指標）：測定可能な3-5個の指標\n\n【OKRの特徴】\n・野心的（ストレッチゴール）：100%達成は逆に目標が低い\n・透明性：全社で共有\n・短いサイクル：四半期ごとに見直し\n・評価との分離：達成度と報酬は直接連動しない\n\n【OKR vs KPI】\n| 項目 | OKR | KPI |\n|------|-----|-----|\n| 目標 | 野心的 | 達成可能 |\n| 達成率 | 60-70% | 100% |\n| 目的 | 成長・挑戦 | 業績管理 |\n\n【導入企業】\nGoogle、Intel、メルカリ等\n\n【他の選択肢】\n・100%達成目標 → 60-70%でOK\n・個人評価連動 → 連動させない（挑戦を促すため）\n・年1回 → 四半期ごと\n\n【覚え方】\nOKR=「野心的な目標を70%達成でOK」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 189,
      "category": "DX利活用",
      "question": "バイモーダルITの説明として正しいものはどれか？",
      "choices": [
        "2つのデータセンターを運用すること",
        "安定性重視のモード1と俊敏性重視のモード2を併用",
        "2種類のプログラミング言語を使用すること",
        "2つのクラウドプロバイダーを利用すること"
      ],
      "answer": 1,
      "explanation": "バイモーダルITは安定性重視の従来型IT（モード1）と、俊敏性重視の実験的IT（モード2）を目的に応じて使い分ける考え方です。\n\n【2つのモード】\n| 項目 | モード1 | モード2 |\n|------|---------|----------|\n| 重視 | 安定性・信頼性 | 俊敏性・革新 |\n| 開発手法 | ウォーターフォール | アジャイル |\n| 対象 | 基幹システム | 新サービス |\n| 変更頻度 | 低い | 高い |\n\n【ガートナーの提唱】\n・2014年にガートナーが提唱\n・両方のモードを併用することが重要\n・DX時代には両方のスキルが必要\n\n【適用例】\n・モード1：会計システム、ERP\n・モード2：顧客向けアプリ、AI実験\n\n【他の選択肢】\n・2つのデータセンター → 災害対策の話\n・2言語 → 技術選定の話\n・2クラウド → マルチクラウドの話\n\n【覚え方】\nバイモーダル=「2つのモード」。安定と俊敏を使い分ける",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 190,
      "category": "DX利活用",
      "question": "SLO（Service Level Objective）の説明として正しいものはどれか？",
      "choices": [
        "サービス提供者と顧客間の契約",
        "サービス品質の目標値",
        "サービス障害時の対応手順",
        "サービスの価格設定"
      ],
      "answer": 1,
      "explanation": "SLOはサービス品質の目標値（例：可用性99.9%）で、SLA（契約）を満たすための内部目標として設定されます。\n\n【SLI/SLO/SLAの関係】\n| 用語 | 意味 | 例 |\n|------|------|----|\n| SLI | 指標 | 可用性、レイテンシ |\n| SLO | 目標値 | 可用性99.9% |\n| SLA | 契約 | 違反時は返金 |\n\n【可用性の計算例】\n・99.9%（スリーナイン）：年間ダウンタイム約8.8時間\n・99.99%（フォーナイン）：年間約52分\n・99.999%（ファイブナイン）：年間約5分\n\n【エラーバジェット】\n・SLOとの差分が許容される障害量\n・例：99.9%目標なら0.1%分は障害OK\n\n【他の選択肢】\n・顧客との契約 → SLAの説明\n・障害対応手順 → インシデント管理\n・価格設定 → 料金体系\n\n【覚え方】\nSLO=Service Level Objective（目標）。「内部で目指す品質レベル」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 191,
      "category": "DX利活用",
      "question": "技術的負債の説明として正しいものはどれか？",
      "choices": [
        "ITシステムへの投資コスト",
        "短期的解決策の蓄積による将来の追加作業",
        "ハードウェアの減価償却",
        "ソフトウェアライセンス費用"
      ],
      "answer": 1,
      "explanation": "技術的負債は短期的な解決策や妥協の蓄積により、将来のメンテナンスや機能追加が困難になる状態を指します。\n\n【技術的負債の例】\n・コードの重複\n・不適切な設計\n・テストコードの不足\n・ドキュメントの未整備\n・古いライブラリの放置\n\n【技術的負債が生まれる原因】\n・納期優先の開発\n・スキル不足\n・仕様変更の蓄積\n・リファクタリング不足\n\n【技術的負債のコスト】\n・開発速度の低下\n・バグ発生率の増加\n・新人の学習コスト増大\n・システム刷新の困難さ\n\n【対策】\n・定期的なリファクタリング\n・コードレビューの実施\n・技術的負債の可視化\n\n【他の選択肢】\n・IT投資コスト → 設備投資\n・減価償却 → 会計処理\n・ライセンス費用 → 運用コスト\n\n【覚え方】\n技術的負債=「将来返さなければならない借金」。今楽をすると後で苦労する",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 192,
      "category": "DX利活用",
      "question": "準委任契約と請負契約の違いとして正しいものはどれか？",
      "choices": [
        "準委任契約は成果物の完成責任がある",
        "請負契約は作業時間に対して報酬が支払われる",
        "準委任契約は作業の遂行に対して報酬が支払われる",
        "両者に違いはない"
      ],
      "answer": 2,
      "explanation": "準委任契約は作業の遂行（善管注意義務）に対して報酬が支払われ、請負契約は成果物の完成に対して報酬が支払われます。\n\n【準委任契約 vs 請負契約】\n| 項目 | 準委任契約 | 請負契約 |\n|------|------------|----------|\n| 報酬基準 | 作業遂行 | 成果物完成 |\n| 完成責任 | なし | あり |\n| 瑕疵担保 | 原則なし | あり |\n| 適用例 | 運用保守、コンサル | 開発、制作 |\n\n【善管注意義務】\n・準委任契約における受任者の義務\n・「善良なる管理者の注意」をもって業務を行う\n・専門家として適切な注意を払う義務\n\n【IT業界での使い分け】\n・要件定義・設計フェーズ → 準委任が多い\n・開発・製造フェーズ → 請負が多い\n・運用保守 → 準委任が多い\n\n【他の選択肢】\n・準委任に完成責任 → なし\n・請負は時間報酬 → 成果物報酬\n・両者同じ → 明確に異なる\n\n【覚え方】\n準委任=「お任せ」、請負=「完成お届け」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 193,
      "category": "DX利活用",
      "question": "個人情報保護法における「要配慮個人情報」に該当するものはどれか？",
      "choices": [
        "氏名",
        "住所",
        "病歴",
        "電話番号"
      ],
      "answer": 2,
      "explanation": "要配慮個人情報は人種、信条、病歴、犯罪歴など、不当な差別や偏見につながりうる情報で、取得に本人の同意が必要です。\n\n【要配慮個人情報の種類】\n・人種、信条、社会的身分\n・病歴、心身の機能障害\n・犯罪歴、犯罪被害\n・健康診断結果\n・遺伝情報\n\n【通常の個人情報との違い】\n| 項目 | 通常の個人情報 | 要配慮個人情報 |\n|------|----------------|----------------|\n| 取得 | 利用目的通知 | 本人同意必要 |\n| オプトアウト | 可能 | 不可 |\n| 漏洩リスク | 中程度 | 高い |\n\n【個人情報の分類】\n・個人情報：氏名、住所、電話番号等\n・要配慮個人情報：差別につながりうる情報\n・個人識別符号：マイナンバー、指紋等\n\n【他の選択肢】\n・氏名、住所、電話番号 → 通常の個人情報\n・病歴 → 要配慮個人情報\n\n【覚え方】\n要配慮個人情報=「差別につながりうるセンシティブ情報」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 194,
      "category": "DX利活用",
      "question": "DXレポートで指摘された「SAP 2027年問題」とは何か？",
      "choices": [
        "SAP製品の価格が高騰する",
        "SAP ERP 6.0の標準サポートが終了する",
        "SAPがサービスを終了する",
        "SAP製品が日本から撤退する"
      ],
      "answer": 1,
      "explanation": "SAP ERP 6.0の標準サポートが2027年に終了予定（延長で2030年）で、多くの企業がシステム刷新を迫られています。\n\n【SAP 2027年問題の背景】\n・SAP ERP 6.0は多くの日本企業で利用\n・2027年末に標準サポート終了（延長で2030年）\n・SAP S/4HANAへの移行が必要\n\n【影響を受ける企業】\n・大企業の基幹システム\n・製造業、流通業で広く導入\n・日本では数千社が対象\n\n【移行の選択肢】\n・S/4HANAへのマイグレーション\n・他ERPへの乗り換え\n・延長サポートの利用（有償）\n\n【課題】\n・移行コストの高さ\n・IT人材の不足\n・アドオン（カスタマイズ）の見直し\n\n【他の選択肢】\n・価格高騰 → 主な問題ではない\n・サービス終了 → SAP社は継続\n・日本撤退 → 事実ではない\n\n【覚え方】\n2027年問題=「SAPサポート終了で基幹システム刷新待ったなし」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 195,
      "category": "DX利活用",
      "question": "ITILの目的として正しいものはどれか？",
      "choices": [
        "ソフトウェア開発プロセスの標準化",
        "ITサービス管理のベストプラクティス",
        "ネットワーク機器の設定標準化",
        "プログラミング言語の標準化"
      ],
      "answer": 1,
      "explanation": "ITIL（IT Infrastructure Library）はITサービス管理のベストプラクティスをまとめたフレームワークです。\n\n【ITILの主要プロセス】\n・インシデント管理：障害の迅速な復旧\n・問題管理：根本原因の究明と再発防止\n・変更管理：変更による影響を最小化\n・リリース管理：本番環境への適切な展開\n・構成管理：IT資産の把握と管理\n\n【ITILのバージョン】\n・ITIL v2：プロセス中心\n・ITIL v3/2011：サービスライフサイクル\n・ITIL 4：アジャイル、DevOpsとの連携\n\n【関連資格】\n・ITIL Foundation：基礎レベル\n・ITIL Specialist/Leader：上位レベル\n\n【他の選択肢】\n・ソフトウェア開発標準 → CMMI、ISO 12207等\n・ネットワーク機器設定 → ベンダー固有の設定\n・プログラミング言語 → ISO/IEC等\n\n【覚え方】\nITIL=IT Infrastructure Library。「ITサービス運用の教科書」",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 196,
      "category": "DX利活用",
      "question": "MVP（Minimum Viable Product）の目的として正しいものはどれか？",
      "choices": [
        "完全な機能を持つ製品を作る",
        "最小限の機能で仮説を検証する",
        "コストを最小化する",
        "開発期間を短縮する"
      ],
      "answer": 1,
      "explanation": "MVPは仮説検証に必要な最小限の機能を持つ製品で、市場からのフィードバックを得て学習することが目的です。\n\n【MVPの目的】\n・最小限の投資で仮説を検証\n・市場からフィードバックを得る\n・素早く学習して方向転換\n\n【MVPの例】\n・ランディングページ：興味があるか確認\n・動画説明：製品イメージを伝える\n・コンシェルジュ型：手作業でサービス提供\n・ウィザードオブオズ型：裏で人が処理\n\n【MVP vs プロトタイプ vs PoC】\n| 用語 | 目的 | 対象 |\n|------|------|------|\n| MVP | 市場検証 | 顧客 |\n| プロトタイプ | 設計確認 | 開発チーム |\n| PoC | 技術検証 | 社内 |\n\n【他の選択肢】\n・完全な機能 → 最小限が原則\n・コスト最小化 → 学習が目的\n・開発期間短縮 → 副次的効果\n\n【覚え方】\nMVP=Minimum Viable Product。「最小限で動く製品」で市場を試す",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 197,
      "category": "DX利活用",
      "question": "内製化のメリットとして正しいものはどれか？",
      "choices": [
        "初期コストが低い",
        "外部の専門知識を活用できる",
        "ノウハウの蓄積とスピーディーな改善",
        "人材確保の必要がない"
      ],
      "answer": 2,
      "explanation": "内製化により社内にノウハウが蓄積され、要件変更への迅速な対応や継続的な改善が可能になります。\n\n【内製化のメリット】\n・ノウハウの社内蓄積\n・素早い改善サイクル\n・ビジネス理解が深いチーム\n・長期的なコスト削減\n\n【内製化のデメリット】\n・初期コストが高い\n・人材確保・育成が必要\n・技術の陳腐化リスク\n\n【内製化 vs 外注】\n| 項目 | 内製化 | 外注 |\n|------|--------|------|\n| ノウハウ | 社内蓄積 | 社外流出 |\n| コスト | 初期高、長期低 | 初期低、長期高 |\n| スピード | 素早い | 調整必要 |\n| 専門性 | 育成必要 | 調達可能 |\n\n【DXと内製化】\n・DX推進には内製化が重要視されている\n・アジャイル開発との相性が良い\n\n【他の選択肢】\n・初期コスト低 → 逆に高い\n・外部専門知識 → 外注のメリット\n・人材不要 → 人材確保が課題\n\n【覚え方】\n内製化=「自分たちで作る」。ノウハウとスピードを手に入れる",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 198,
      "category": "DX利活用",
      "question": "DX推進における「両利きの経営」とは何か？",
      "choices": [
        "2つのビジネスを同時に行うこと",
        "既存事業の深化と新規事業の探索を両立",
        "国内と海外の両方で事業展開",
        "製造と販売の両方を自社で行うこと"
      ],
      "answer": 1,
      "explanation": "両利きの経営は既存事業の「深化」（効率化・改善）と新規事業の「探索」（イノベーション）を同時に追求する経営手法です。\n\n【両利きの経営の2つの軸】\n| 軸 | 内容 | 例 |\n|----|------|----|\n| 深化 | 既存事業の効率化 | コスト削減、品質向上 |\n| 探索 | 新規事業の開拓 | 新市場、新技術 |\n\n【なぜ両利きが必要か】\n・深化だけ → イノベーションのジレンマ\n・探索だけ → 収益基盤が不安定\n・両方 → 持続的成長\n\n【実現のポイント】\n・組織的分離：探索チームを独立させる\n・経営層のコミット：両方を支援\n・資源配分：探索にも投資\n\n【関連概念】\n・イノベーションのジレンマ（クリステンセン）\n・破壊的イノベーション\n\n【他の選択肢】\n・2つのビジネス → 深化と探索の両立\n・国内外展開 → グローバル戦略\n・製造販売両立 → 垂直統合\n\n【覚え方】\n両利き=「右手で守り、左手で攻める」。既存と新規の両立",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 199,
      "category": "DX利活用",
      "question": "SoR（System of Record）の特徴として正しいものはどれか？",
      "choices": [
        "顧客との関係構築を重視",
        "記録・管理を目的とした基幹システム",
        "データ分析を主目的としたシステム",
        "外部連携を重視したシステム"
      ],
      "answer": 1,
      "explanation": "SoRは会計や在庫管理など、正確なデータ記録と管理を目的とした基幹システムです。SoE（System of Engagement）は顧客接点システムです。\n\n【3つのシステム分類】\n| 分類 | 目的 | 例 |\n|------|------|----|\n| SoR | 記録・管理 | ERP、会計、在庫 |\n| SoE | 顧客接点 | ECサイト、CRM |\n| SoI | 分析・洞察 | BI、データ分析 |\n\n【SoR（System of Record）の特徴】\n・データの正確性が最重要\n・トランザクション処理\n・変更頻度が低い\n・安定性重視\n\n【SoE（System of Engagement）の特徴】\n・ユーザー体験が重要\n・頻繁な変更・改善\n・俊敏性重視\n・顧客との接点\n\n【他の選択肢】\n・顧客関係構築 → SoEの特徴\n・データ分析 → SoI（Insight）の特徴\n・外部連携 → API連携の話\n\n【覚え方】\nSoR=Record（記録）、SoE=Engagement（つながり）、SoI=Insight（洞察）",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    },
    {
      "id": 200,
      "category": "DX利活用",
      "question": "アジャイル開発のレトロスペクティブの目的はどれか？",
      "choices": [
        "次のスプリントの計画を立てる",
        "プロダクトバックログを整理する",
        "チームの振り返りと改善点の特定",
        "成果物のデモを行う"
      ],
      "answer": 2,
      "explanation": "レトロスペクティブはスプリント終了後にチームで振り返りを行い、プロセスや協力方法の改善点を特定するミーティングです。\n\n【レトロスペクティブの進め方】\n1. 良かったこと（Keep）\n2. 問題点（Problem）\n3. 改善案（Try）\n→ KPT法が代表的\n\n【スクラムイベントとの関係】\n| イベント | 目的 |\n|----------|------|\n| スプリント計画 | 何を作るか決める |\n| デイリースクラム | 進捗共有 |\n| スプリントレビュー | 成果物をデモ |\n| レトロスペクティブ | プロセス改善 |\n\n【レトロスペクティブのポイント】\n・全員が発言できる安全な場\n・批判ではなく改善にフォーカス\n・具体的なアクションを決める\n\n【他の選択肢】\n・次スプリント計画 → スプリント計画会議\n・バックログ整理 → バックログリファインメント\n・成果物デモ → スプリントレビュー\n\n【覚え方】\nレトロスペクティブ=「振り返り」。チームがより良くなるための会議",
      "source": {
        "type": "original"
      },
      "difficulty": 2
    }
  ]
}